{
  "updatedAt": "2026-02-17T09:31:57.763Z",
  "createdAt": "2026-01-26T13:37:27.928Z",
  "id": "4Nqc0B8DU_OcFoxfK3tMD",
  "name": "n8n UGC latest",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "path": "phase-1",
        "options": {}
      },
      "id": "webhook-trigger-001",
      "name": "Phase 1: Discovery",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1600,
        300
      ],
      "webhookId": "phase-1"
    },
    {
      "parameters": {
        "jsCode": "// Collect profiles from this competitor batch\nreturn $input.all();"
      },
      "id": "c986d0d4-658f-49ac-95fe-e8c36adf89fd",
      "name": "Collect Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -740,
        300
      ]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "allProfiles",
        "options": {}
      },
      "id": "d6868484-862b-4db8-b50a-f03ee54c9aad",
      "name": "Aggregate All",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        -520,
        300
      ],
      "notesInFlow": true,
      "notes": "Collects profiles from all competitors"
    },
    {
      "parameters": {
        "jsCode": "// Deduplicate profiles across all competitors\nconst data = $input.first().json;\nconst allProfiles = data.allProfiles || [];\nconst unique = new Map();\n\nfor (const p of allProfiles) {\n  if (!p.username) continue;\n  if (!unique.has(p.username)) {\n    unique.set(p.username, p);\n  }\n}\n\nconst deduped = Array.from(unique.values());\nconsole.log(`Total unique profiles after deduplication: ${deduped.length}`);\n\nreturn deduped.map(p => ({ json: p }));"
      },
      "id": "7d6e46d9-842e-4931-84cb-4c473fb6a9ca",
      "name": "Dedupe Profiles",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -300,
        300
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Filter Reels: Extract top 3 reels, calculate engagement, skip invalid profiles\nconst profile = $input.item.json;\nconst settings = $('Settings1').first().json;\n\n// Source info is passed through from Pre-Filter Known Profiles \u2192 Apify\n// Fall back to 'unknown' if not available\nconst preFiltered = $('Pre-Filter Known Profiles').all();\nconst sourceMatch = preFiltered.find(p => p.json.username === profile.username);\nconst sourceData = sourceMatch?.json || { source: 'unknown', sourceType: 'tagged' };\nconst followers = Number(profile.followersCount) || 0;\n\nif (!profile.followersCount || followers === 0) {\n  return { json: { _skip: true, username: profile.username || 'unknown', reason: 'private_or_empty' } };\n}\n\n// Skip profiles outside follower range (2k-150k)\nif (followers < settings.minFollowers || followers > settings.maxFollowers) {\n  return { json: { _skip: true, username: profile.username, followers: followers, reason: 'outside_follower_range' } };\n}\n\nconst posts = profile.latestPosts || [];\n\nif (posts.length === 0) {\n  return { json: { _skip: true, username: profile.username || 'unknown', reason: 'no_posts_returned' } };\n}\n\nconst reels = posts.filter(post => {\n  const isClip = (post.productType === 'clips');\n  const isVideo = (post.type === 'Video' && post.productType !== 'igtv');\n  if (post.videoDuration) {\n    const dur = Number(post.videoDuration);\n    if (dur < 15 || dur > 90) return false;\n  }\n  return isClip || isVideo;\n});\n\nlet qualifyingReels = reels;\nif (qualifyingReels.length === 0) {\n  qualifyingReels = posts.filter(post =>\n    post.type === 'Video' || post.productType === 'clips' || post.productType === 'igtv'\n  );\n}\n\nqualifyingReels.sort((a, b) => {\n  const engA = (Number(a.likesCount) || 0) + (Number(a.commentsCount) || 0);\n  const engB = (Number(b.likesCount) || 0) + (Number(b.commentsCount) || 0);\n  return engB - engA;\n});\n\nconst topReels = qualifyingReels.slice(0, 3);\nlet engagement_rate = 0, avg_likes = 0, avg_comments = 0, avg_duration = 0;\n\nif (qualifyingReels.length > 0 && followers > 0) {\n  const totalLikes = qualifyingReels.reduce((sum, r) => sum + (Number(r.likesCount) || 0), 0);\n  const totalComments = qualifyingReels.reduce((sum, r) => sum + (Number(r.commentsCount) || 0), 0);\n  const totalDuration = qualifyingReels.reduce((sum, r) => sum + (Number(r.videoDuration) || 0), 0);\n  avg_likes = Math.round(totalLikes / qualifyingReels.length);\n  avg_comments = Math.round(totalComments / qualifyingReels.length);\n  const reelsWithDur = qualifyingReels.filter(r => r.videoDuration);\n  avg_duration = reelsWithDur.length > 0 ? Math.round(totalDuration / reelsWithDur.length) : 0;\n  const avgEngagement = (totalLikes + totalComments) / qualifyingReels.length;\n  engagement_rate = Number(((avgEngagement / followers) * 100).toFixed(2));\n}\n\nif (qualifyingReels.length === 0 && posts.length > 0 && followers > 0) {\n  const totalLikes = posts.reduce((sum, p) => sum + (Number(p.likesCount) || 0), 0);\n  const totalComments = posts.reduce((sum, p) => sum + (Number(p.commentsCount) || 0), 0);\n  avg_likes = Math.round(totalLikes / posts.length);\n  avg_comments = Math.round(totalComments / posts.length);\n  engagement_rate = Number((((totalLikes + totalComments) / posts.length / followers) * 100).toFixed(2));\n}\n\nfunction getVideoUrl(post) {\n  if (post.videoUrl) return post.videoUrl;\n  return '';\n}\n\nfunction getPostUrl(post) {\n  if (post.url) return post.url;\n  if (post.shortCode) return `https://www.instagram.com/reel/${post.shortCode}/`;\n  return '';\n}\n\nreturn {\n  json: {\n    username: profile.username,\n    followers: followers,\n    bio: (profile.biography || '').substring(0, 500),\n    source: sourceData.source || 'unknown',\n    source_type: sourceData.sourceType || 'tagged',\n    has_art_content: true,\n    verified: profile.verified || false,\n    engagement_rate: engagement_rate,\n    avg_likes: avg_likes,\n    avg_comments: avg_comments,\n    avg_duration: avg_duration,\n    total_reels_found: qualifyingReels.length,\n\n    reel_1_url: topReels[0] ? getVideoUrl(topReels[0]) : '',\n    reel_1_post_url: topReels[0] ? getPostUrl(topReels[0]) : '',\n    reel_1_likes: topReels[0] ? (Number(topReels[0].likesCount) || 0) : 0,\n    reel_1_comments: topReels[0] ? (Number(topReels[0].commentsCount) || 0) : 0,\n    reel_1_duration: topReels[0] ? (Number(topReels[0].videoDuration) || 0) : 0,\n    reel_1_caption: topReels[0] ? (topReels[0].caption || '').substring(0, 300) : '',\n\n    reel_2_url: topReels[1] ? getVideoUrl(topReels[1]) : '',\n    reel_2_post_url: topReels[1] ? getPostUrl(topReels[1]) : '',\n    reel_2_likes: topReels[1] ? (Number(topReels[1].likesCount) || 0) : 0,\n    reel_2_comments: topReels[1] ? (Number(topReels[1].commentsCount) || 0) : 0,\n    reel_2_duration: topReels[1] ? (Number(topReels[1].videoDuration) || 0) : 0,\n    reel_2_caption: topReels[1] ? (topReels[1].caption || '').substring(0, 300) : '',\n\n    reel_3_url: topReels[2] ? getVideoUrl(topReels[2]) : '',\n    reel_3_post_url: topReels[2] ? getPostUrl(topReels[2]) : '',\n    reel_3_likes: topReels[2] ? (Number(topReels[2].likesCount) || 0) : 0,\n    reel_3_comments: topReels[2] ? (Number(topReels[2].commentsCount) || 0) : 0,\n    reel_3_duration: topReels[2] ? (Number(topReels[2].videoDuration) || 0) : 0,\n    reel_3_caption: topReels[2] ? (topReels[2].caption || '').substring(0, 300) : '',\n\n    analyzed_at: new Date().toISOString()\n  }\n};"
      },
      "id": "b411c782-4828-4eda-ae70-8c6c39854954",
      "name": "Filter Reels",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        580,
        300
      ],
      "notesInFlow": true,
      "notes": "\u2705 Enhanced: engagement rate, hashtags, pre-filtering"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "anthropicApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-sonnet-4-20250514\",\n  \"max_tokens\": 1024,\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": {{ JSON.stringify(\"Evaluate this Instagram creator for potential UGC partnership with 21Draw, an online art education platform.\\n\\nPROFILE DATA:\\nUsername: \" + $json.username + \"\\nFollowers: \" + $json.followers + \"\\nEngagement Rate: \" + ($json.engagement_rate || 0) + \"%\\nAvg Likes: \" + ($json.avg_likes || 0) + \"\\nAvg Comments: \" + ($json.avg_comments || 0) + \"\\nBio: \" + ($json.bio || \"\").replace(/[\\n\\r]/g, \" \") + \"\\nVerified: \" + $json.verified + \"\\nBusiness Category: \" + ($json.business_category || \"none\") + \"\\nTotal Reels Found: \" + ($json.total_reels_found || 0) + \"\\n\\nTOP REELS:\\nReel 1: \" + ($json.reel_1_url || \"none\") + \"\\n- Likes: \" + ($json.reel_1_likes || 0) + \" | Comments: \" + ($json.reel_1_comments || 0) + \"\\n- Caption: \" + ($json.reel_1_caption || \"\").replace(/[\\n\\r]/g, \" \") + \"\\n\\nReel 2: \" + ($json.reel_2_url || \"none\") + \"\\n- Likes: \" + ($json.reel_2_likes || 0) + \" | Comments: \" + ($json.reel_2_comments || 0) + \"\\n- Caption: \" + ($json.reel_2_caption || \"\").replace(/[\\n\\r]/g, \" \") + \"\\n\\nReel 3: \" + ($json.reel_3_url || \"none\") + \"\\n- Likes: \" + ($json.reel_3_likes || 0) + \" | Comments: \" + ($json.reel_3_comments || 0) + \"\\n- Caption: \" + ($json.reel_3_caption || \"\").replace(/[\\n\\r]/g, \" \") + \"\\n\\nEVALUATION CRITERIA:\\n- Niche relevance to art education (drawing, painting, sculpting, digital art, art tutorials)\\n- Engagement quality (likes, comments relative to followers)\\n- Content style fit for educational art platform\\n- Follower count (accounts with 5k+ followers in art niche are valuable)\\n- Even accounts with lower engagement rates should be COLLABORATE if they have strong art content and decent following\\n\\nRecommendation options:\\n- COLLABORATE: Strong fit, good metrics, art-relevant content\\n- REVIEW: Promising but needs manual review\\n- PASS: Not a good fit for 21Draw\\n- REJECT: Clearly unsuitable (spam, no art content, very low following)\\n\\nRespond with JSON only, no other text:\\n{\\\"niche_relevance\\\": 1-10, \\\"profile_score\\\": 1-10, \\\"recommendation\\\": \\\"COLLABORATE/REVIEW/PASS/REJECT\\\", \\\"reasoning\\\": \\\"your explanation here\\\"}\") }}\n    }\n  ]\n}",
        "options": {}
      },
      "id": "f080cdfb-72c3-4242-9669-84a50aa8f3ed",
      "name": "Claude Analysis",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1020,
        300
      ],
      "notesInFlow": true,
      "retryOnFail": true,
      "waitBetweenTries": 5000,
      "maxTries": 5,
      "credentials": {
        "anthropicApi": {
          "id": "6Ysrp6eyFvQXqLWi",
          "name": "Anthropic account"
        }
      },
      "notes": "\u2705 Fixed: Honest prompt about limitations"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Merge node: Combines Claude API response with profile data\n// AND logs the Claude call to ai_logs for audit trail\n// NOTE: Claude Analysis itself is an HTTP Request node (POST to api.anthropic.com)\n//       Model: claude-sonnet-4-20250514, max_tokens: 1024\n//       This code runs in the \"Merge\" node AFTER Claude returns its response.\n//\n// n8n WIRING:\n// Claude Analysis \u2192 this node \u2192 Save DB\n\nconst https = require('https');\nconst PROMPT_VERSION_CLAUDE = 1;\n\nconst index = $itemIndex;\nconst profileData = $('Has Reels?').all()[index];\nconst claudeResponse = $input.item.json;\n\nconst profile = profileData?.json || {};\nconst username = profile.username || null;\n\n// Extract raw response text and token usage\nconst rawText = claudeResponse.content?.[0]?.text || '{}';\nconst tokensUsed = (claudeResponse.usage?.input_tokens || 0) + (claudeResponse.usage?.output_tokens || 0);\n\n// Skip empty/failed Claude responses \u2014 don't save bad data to profiles\nif (!claudeResponse.content || tokensUsed === 0) {\n  // Still log the failure to ai_logs for debugging\n  const SUPABASE_KEY_EARLY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n  try {\n    const logData = JSON.stringify({\n      profile_username: username,\n      workflow_name: 'WF-Profile-Analysis',\n      model_used: 'claude-sonnet-4-20250514',\n      prompt_sent: `FAILED: ${username}`,\n      input_data: JSON.stringify({ username, followers: profile.followers }),\n      output_raw: JSON.stringify(claudeResponse).substring(0, 500),\n      output_parsed: '{}',\n      tokens_used: 0,\n      prompt_version: PROMPT_VERSION_CLAUDE\n    });\n    const https2 = require('https');\n    await new Promise((resolve) => {\n      const req = https2.request({\n        hostname: 'gwytongsbnciyulphcjv.supabase.co',\n        path: '/rest/v1/ai_logs',\n        method: 'POST',\n        headers: {\n          'apikey': SUPABASE_KEY_EARLY,\n          'Authorization': `Bearer ${SUPABASE_KEY_EARLY}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal',\n          'Content-Length': Buffer.byteLength(logData)\n        }\n      }, resolve);\n      req.on('error', resolve);\n      req.write(logData);\n      req.end();\n    });\n  } catch (e) { /* ignore */ }\n\n  return { json: { _skip: true, username: username, reason: 'empty_claude_response' } };\n}\n\nlet analysis = {};\ntry {\n  let text = rawText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n  analysis = JSON.parse(text);\n} catch (e) {\n  analysis = {\n    recommendation: 'REVIEW',\n    reasoning: 'Could not parse AI analysis',\n    profile_score: 5,\n    niche_relevance: 5\n  };\n}\n\n// \u2500\u2500 Log Claude call to ai_logs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabasePost(path, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: 'POST',\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal',\n        'Content-Length': Buffer.byteLength(data)\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data: responseData }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\ntry {\n  await supabasePost('/rest/v1/ai_logs', {\n    profile_username: username,\n    workflow_name: 'WF-Profile-Analysis',\n    model_used: 'claude-sonnet-4-20250514',\n    prompt_sent: `Evaluate creator: ${username} (${profile.followers} followers, ${profile.engagement_rate} engagement)`,\n    input_data: JSON.stringify({\n      username: username,\n      followers: profile.followers,\n      bio: profile.bio,\n      engagement_rate: profile.engagement_rate,\n      total_reels_found: profile.total_reels_found\n    }),\n    output_raw: rawText,\n    output_parsed: JSON.stringify(analysis),\n    tokens_used: tokensUsed,\n    prompt_version: PROMPT_VERSION_CLAUDE\n  });\n} catch (e) {\n  console.log('Failed to log Claude call to ai_logs:', e.message);\n}\n\nreturn {\n  json: {\n    username: username,\n    followers: profile.followers || 0,\n    bio: profile.bio || '',\n    source: profile.source || '',\n    source_type: profile.sourceType || '',\n    has_art_content: profile.has_art_content || false,\n    verified: profile.verified || false,\n    niche_relevance: analysis.niche_relevance || 5,\n    profile_score: analysis.profile_score || 5,\n    recommendation: analysis.recommendation || 'REVIEW',\n    reasoning: analysis.reasoning || '',\n    status: 'PENDING_REVIEW',\n    analyzed_at: new Date().toISOString(),\n    engagement_rate: profile.engagement_rate || 0,\n    avg_likes: profile.avg_likes || 0,\n    avg_comments: profile.avg_comments || 0,\n    avg_duration: profile.avg_duration || 0,\n    total_reels_found: profile.total_reels_found || 0,\n    prompt_version: PROMPT_VERSION_CLAUDE,\n\n    reel_1_url: profile.reel_1_url || '',\n    reel_1_post_url: profile.reel_1_post_url || '',\n    reel_1_likes: profile.reel_1_likes || 0,\n    reel_1_comments: profile.reel_1_comments || 0,\n    reel_1_duration: profile.reel_1_duration || 0,\n    reel_1_caption: profile.reel_1_caption || '',\n\n    reel_2_url: profile.reel_2_url || '',\n    reel_2_post_url: profile.reel_2_post_url || '',\n    reel_2_likes: profile.reel_2_likes || 0,\n    reel_2_comments: profile.reel_2_comments || 0,\n    reel_2_duration: profile.reel_2_duration || 0,\n    reel_2_caption: profile.reel_2_caption || '',\n\n    reel_3_url: profile.reel_3_url || '',\n    reel_3_post_url: profile.reel_3_post_url || '',\n    reel_3_likes: profile.reel_3_likes || 0,\n    reel_3_comments: profile.reel_3_comments || 0,\n    reel_3_duration: profile.reel_3_duration || 0,\n    reel_3_caption: profile.reel_3_caption || ''\n  }\n};\n"
      },
      "id": "f6b4ee91-463b-42ca-84b2-fb94f5754783",
      "name": "Merge Claude Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1240,
        300
      ],
      "notesInFlow": true,
      "notes": "\u2705 Enhanced: better error handling, all fields mapped"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Save to DB \u2014 Phase 1 Code Node\n// Inserts or upserts the Claude-analyzed profile into the profiles table.\n// Uses native https to avoid n8n Supabase node credential issues.\n//\n// n8n WIRING:\n// Merge (Claude Analysis) \u2192 this node \u2192 Download & Store Reels\n\nconst https = require('https');\nconst profile = $input.item.json;\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabasePost(path, body, extraHeaders) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: 'POST',\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal,resolution=merge-duplicates',\n        'Content-Length': Buffer.byteLength(data),\n        ...extraHeaders\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => {\n        if (res.statusCode >= 200 && res.statusCode < 300) {\n          resolve({ status: res.statusCode, data: responseData });\n        } else {\n          reject(new Error(`Supabase ${res.statusCode}: ${responseData}`));\n        }\n      });\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\n// Debug: log to debug_log table\nasync function debugLog(username, message, data) {\n  try {\n    await supabasePost('/rest/v1/debug_log', {\n      node_name: 'Save DB',\n      username: username || 'unknown',\n      message: message,\n      data: typeof data === 'string' ? data.substring(0, 500) : JSON.stringify(data).substring(0, 500)\n    }, { 'Prefer': 'return=minimal' });\n  } catch (e) {\n    // ignore debug log failures\n  }\n}\n\nawait debugLog(profile.username, 'ENTER Save DB', {\n  has_username: !!profile.username,\n  has_source: !!profile.source,\n  keys: Object.keys(profile).length\n});\n\nif (profile._skip) {\n  await debugLog(profile.username || 'unknown', 'SKIP - empty Claude response', profile);\n  return { json: profile };\n}\n\nif (!profile.username) {\n  await debugLog('null', 'SKIP - no username', profile);\n  return { json: profile };\n}\n\nconst row = {\n  username: profile.username,\n  followers: profile.followers || 0,\n  bio: profile.bio || '',\n  source: profile.source || '',\n  source_type: profile.source_type || '',\n  has_art_content: profile.has_art_content || false,\n  verified: profile.verified || false,\n  niche_relevance: profile.niche_relevance || 5,\n  profile_score: profile.profile_score || 5,\n  recommendation: profile.recommendation || 'REVIEW',\n  reasoning: profile.reasoning || '',\n  status: profile.status || 'PENDING_REVIEW',\n  analyzed_at: profile.analyzed_at || new Date().toISOString(),\n  engagement_rate: profile.engagement_rate || 0,\n  avg_likes: profile.avg_likes || 0,\n  avg_comments: profile.avg_comments || 0,\n  avg_duration: profile.avg_duration || 0,\n  total_reels_found: profile.total_reels_found || 0,\n  prompt_version: profile.prompt_version || 1,\n  reel_1_url: profile.reel_1_url || '',\n  reel_1_post_url: profile.reel_1_post_url || '',\n  reel_1_likes: profile.reel_1_likes || 0,\n  reel_1_comments: profile.reel_1_comments || 0,\n  reel_1_duration: profile.reel_1_duration || 0,\n  reel_1_caption: profile.reel_1_caption || '',\n  reel_2_url: profile.reel_2_url || '',\n  reel_2_post_url: profile.reel_2_post_url || '',\n  reel_2_likes: profile.reel_2_likes || 0,\n  reel_2_comments: profile.reel_2_comments || 0,\n  reel_2_duration: profile.reel_2_duration || 0,\n  reel_2_caption: profile.reel_2_caption || '',\n  reel_3_url: profile.reel_3_url || '',\n  reel_3_post_url: profile.reel_3_post_url || '',\n  reel_3_likes: profile.reel_3_likes || 0,\n  reel_3_comments: profile.reel_3_comments || 0,\n  reel_3_duration: profile.reel_3_duration || 0,\n  reel_3_caption: profile.reel_3_caption || ''\n};\n\ntry {\n  await supabasePost('/rest/v1/profiles?on_conflict=username', row);\n  await debugLog(profile.username, 'SUCCESS', { status: 'upserted' });\n} catch (e) {\n  await debugLog(profile.username, 'ERROR: ' + e.message, { row_keys: Object.keys(row) });\n}\n\nreturn { json: profile };\n"
      },
      "id": "7088a7fd-a93d-4035-b59e-ca94dc87986a",
      "name": "Save DB",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1460,
        300
      ],
      "notesInFlow": true,
      "onError": "continueRegularOutput",
      "notes": "\u2705 Code node: native HTTPS insert to profiles"
    },
    {
      "parameters": {},
      "id": "6b5167f8-6b38-4133-ac52-995506b31206",
      "name": "Phase 1 Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1900,
        300
      ],
      "notesInFlow": true,
      "notes": "\u2705 Phase 1 Complete!"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.apify.com/v2/acts/apify~instagram-scraper/run-sync-get-dataset-items",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "apifyApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"directUrls\": [\"https://www.instagram.com/{{ $json.competitor }}/tagged/\"],\n  \"resultsLimit\": {{ $json.resultsLimit }},\n  \"resultsType\": \"posts\"\n}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "21c6879a-68d1-4c2c-ac85-6bbe065a661d",
      "name": "Apify: Tagged Posts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1180,
        300
      ],
      "credentials": {
        "apifyApi": {
          "id": "UXM2kDAyAdkPfO2Q",
          "name": "Apify account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// ====== SETTINGS ======\nconst COMPETITORS = [\n  \"aaronblaiseart\",\n  \"rchrd.powell\"\n];\nconst RESULTS_LIMIT = 200;\nconst SIMILAR_LIMIT = 100;\nconst MIN_FOLLOWERS = 2000;\nconst MAX_FOLLOWERS = 200000;\n// ======================\n\nreturn COMPETITORS.map(competitor => ({\n  json: {\n    competitor: competitor,\n    resultsLimit: RESULTS_LIMIT,\n    similarLimit: SIMILAR_LIMIT,\n    minFollowers: MIN_FOLLOWERS,\n    maxFollowers: MAX_FOLLOWERS,\n    excludeUsernames: COMPETITORS\n  }\n}));"
      },
      "id": "96fb2442-4b09-4386-80d3-0f77a1f8ea9c",
      "name": "Settings1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1400,
        300
      ],
      "notesInFlow": true,
      "notes": "Edit settings here"
    },
    {
      "parameters": {
        "jsCode": "const posts = $input.all().map(i => i.json);\nconst settings = $('Settings1').first().json;\nconst unique = new Map();\n\nconst excludeUsernames = settings.excludeUsernames || [settings.competitor];\n\nfor (const p of posts) {\n  // 1. Owner (for education accounts like domestika - students tag them)\n  const owner = p.ownerUsername;\n  if (owner && !unique.has(owner) && !excludeUsernames.includes(owner)) {\n    unique.set(owner, {\n      username: owner,\n      source: settings.competitor,\n      sourceType: 'tagged'\n    });\n  }\n  \n  // 2. Mentions (for curation accounts like drawing.collection - they feature artists)\n  const mentions = p.mentions || [];\n  for (const m of mentions) {\n    if (m && !unique.has(m) && !excludeUsernames.includes(m)) {\n      unique.set(m, {\n        username: m,\n        source: settings.competitor,\n        sourceType: 'mentioned'\n      });\n    }\n  }\n}\n\nreturn Array.from(unique.values()).map(p => ({ json: p }));"
      },
      "id": "88033fab-eafe-4ad8-8272-8a4c07a5cd3e",
      "name": "Extract Profiles1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -960,
        300
      ]
    },
    {
      "parameters": {
        "operation": "Run actor and get dataset",
        "actorId": {
          "__rl": true,
          "value": "dSCLg0C3YEZ83HzYX",
          "mode": "list",
          "cachedResultName": "Instagram Profile Scraper (apify/instagram-profile-scraper)",
          "cachedResultUrl": "https://console.apify.com/actors/dSCLg0C3YEZ83HzYX/input"
        },
        "customBody": "={\n  \"usernames\": [\"{{ $json.username }}\"],\n  \"resultsLimit\": 50\n}"
      },
      "type": "@apify/n8n-nodes-apify.apify",
      "typeVersion": 1,
      "position": [
        360,
        300
      ],
      "id": "7b6f3298-8a48-42b0-99d6-466afb8cc940",
      "name": "Run an Actor and get dataset",
      "credentials": {
        "apifyApi": {
          "id": "UXM2kDAyAdkPfO2Q",
          "name": "Apify account"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "profiles",
        "limit": 20,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "status",
              "condition": "neq",
              "keyValue": "VIDEO_ANALYZED"
            },
            {
              "keyName": "recommendation",
              "condition": "eq",
              "keyValue": "COLLABORATE"
            },
            {
              "keyName": "status",
              "condition": "neq",
              "keyValue": "DOWNLOAD_FAILED"
            }
          ]
        }
      },
      "name": "Get COLLABORATE Profiles",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1400,
        800
      ],
      "id": "036d8559-5854-4f65-8cad-af4610dbd662",
      "credentials": {
        "supabaseApi": {
          "id": "AK4efiLBvVR50hXA",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "name": "Loop Profiles",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -1180,
        800
      ],
      "id": "bb630022-6c4b-4879-81be-7469a8dcfeae"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyAA63nf0G3Wc4HMhFUL8EWGHX0RqBQyyCs",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "name": "Gemini Video Analysis",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1240,
        800
      ],
      "id": "efd430d8-2e24-4185-9bf7-733324a03b2a"
    },
    {
      "parameters": {
        "tableId": "ai_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "profile_username",
              "fieldValue": "={{ $('Loop Profiles').item.json.username }}"
            },
            {
              "fieldId": "workflow_name",
              "fieldValue": "WF-Video-Analysis"
            },
            {
              "fieldId": "model_used",
              "fieldValue": "gemini-1.5-flash"
            },
            {
              "fieldId": "input_data",
              "fieldValue": "={{ JSON.stringify({ reel_url: $('Loop Profiles').item.json.reel_1_url, username: $('Loop Profiles').item.json.username }) }}"
            },
            {
              "fieldId": "output_raw",
              "fieldValue": "={{ JSON.stringify($json) }}"
            },
            {
              "fieldId": "prompt_version",
              "fieldValue": "1"
            }
          ]
        }
      },
      "name": "Log to AI Logs",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1680,
        800
      ],
      "id": "440a7e98-9b27-4f51-b3e9-3ba591c37521",
      "credentials": {
        "supabaseApi": {
          "id": "AK4efiLBvVR50hXA",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "profiles",
        "filters": {
          "conditions": [
            {
              "keyName": "username",
              "condition": "eq",
              "keyValue": "={{ $('Loop Profiles').item.json.username }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "username",
              "fieldValue": "={{ $('Loop Profiles').item.json.username }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.status_override }}"
            },
            {
              "fieldId": "talks_in_videos",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.talks_in_videos }}"
            },
            {
              "fieldId": "speaks_english",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.speaks_english }}"
            },
            {
              "fieldId": "overall_ugc_score",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.overall_ugc_score }}"
            },
            {
              "fieldId": "content_style",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.video_summary }}"
            },
            {
              "fieldId": "voice_potential",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.voice_potential }}"
            },
            {
              "fieldId": "teaching_potential",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.teaching_potential }}"
            },
            {
              "fieldId": "production_quality",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.content_quality }}"
            },
            {
              "fieldId": "brand_fit",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.brand_fit }}"
            },
            {
              "fieldId": "ugc_reasoning",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.ugc_reasoning }}"
            },
            {
              "fieldId": "video_recommendation",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.recommendation }}"
            },
            {
              "fieldId": "next_steps",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.next_steps }}"
            },
            {
              "fieldId": "audio_description",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.audio_description }}"
            },
            {
              "fieldId": "speech_quote",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.speech_quote }}"
            },
            {
              "fieldId": "videos_with_speech",
              "fieldValue": "={{ $('Parse Gemini Response').item.json.videos_with_speech }}"
            }
          ]
        }
      },
      "name": "Update Profile Status",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1900,
        800
      ],
      "id": "d9e5bff5-579c-468b-ba62-fd0cff788c33",
      "credentials": {
        "supabaseApi": {
          "id": "AK4efiLBvVR50hXA",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {},
      "name": "Phase 2 Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -1180,
        650
      ],
      "id": "e841dc67-febb-4e56-8020-4d958259ff06"
    },
    {
      "parameters": {
        "jsCode": "const item = $('Loop Profiles').item.json;\n\n// Get file URIs from all 3 uploads\nconst fileUri1 = $('Upload Reel 1').item.json?.file?.uri || '';\nconst fileUri2 = $('Upload Reel 2').item.json?.file?.uri || '';\nconst fileUri3 = $('Upload Reel 3').item.json?.file?.uri || '';\n\n// Build parts array with only videos that exist\nconst parts = [];\n\nif (fileUri1) {\n  parts.push({\n    fileData: {\n      mimeType: \"video/mp4\",\n      fileUri: fileUri1\n    }\n  });\n}\n\nif (fileUri2) {\n  parts.push({\n    fileData: {\n      mimeType: \"video/mp4\",\n      fileUri: fileUri2\n    }\n  });\n}\n\nif (fileUri3) {\n  parts.push({\n    fileData: {\n      mimeType: \"video/mp4\",\n      fileUri: fileUri3\n    }\n  });\n}\n\n// Count how many videos we have\nconst videoCount = parts.length;\n\n// \u2500\u2500 SKIP if no videos uploaded (downloads timed out or failed) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nif (videoCount === 0) {\n  return {\n    json: {\n      skip_gemini: true,\n      skip_reason: 'No videos uploaded \u2014 downloads may have timed out',\n      username: item.username\n    }\n  };\n}\n\n// Add the prompt\nparts.push({\n  text: `You are evaluating Instagram creators for UGC partnerships with 21Draw, an online art education platform.\n\nCREATOR INFO:\n- Username: ${item.username}\n- Followers: ${item.followers}\n- Bio: ${item.bio}\n\nREEL 1 CAPTION: ${item.reel_1_caption || 'N/A'}\nREEL 2 CAPTION: ${item.reel_2_caption || 'N/A'}\nREEL 3 CAPTION: ${item.reel_3_caption || 'N/A'}\n\nI have provided ${videoCount} video(s) for you to analyze.\n\nWATCH AND LISTEN TO ALL VIDEOS CAREFULLY. Evaluate the creator based on ALL videos:\n\n1. **talks_in_videos** (true/false): Does the creator SPEAK with their voice in ANY of the videos?\n   - TRUE = creator talks, explains, or narrates with spoken words in at least one video\n   - FALSE = no speech in any video, only music, sound effects, or silence\n   - Background music does NOT count as talking\n   - Text overlays do NOT count as talking\n   - Songs with lyrics do NOT count as the creator talking\n\n2. **audio_description**: What sounds do you HEAR in each video? Be specific. Format:\n   - Reel 1: [describe audio]\n   - Reel 2: [describe audio] (if provided)\n   - Reel 3: [describe audio] (if provided)\n\n3. **speech_quote**: If the creator speaks in ANY video, provide ONE short quote (5-10 words) of what they actually said. If no speech in any video, write \"N/A\".\n\n4. **speaks_english** (true/false): If they speak, is it in English? (false if no speech)\n\n5. **videos_with_speech**: How many of the videos have the creator speaking? (0, 1, 2, or 3)\n\n6. **voice_potential** (0-10): Based on their content style, how likely could they do voiceover work?\n7. **teaching_potential** (0-10): Could they teach art concepts?\n8. **content_quality** (0-10): Production quality and visual appeal\n9. **brand_fit** (0-10): Fit with art education brand\n10. **overall_ugc_score** (0-10): Overall UGC partnership potential\n\n11. **video_summary**: Briefly describe what happens across all videos\n12. **ugc_reasoning**: Why would they be a good/bad UGC partner?\n13. **recommendation**: STRONG_YES / YES / MAYBE / NO\n14. **next_steps**: What to verify before outreach?\n\nIMPORTANT: Be accurate about audio. Do not assume speech exists just because it's a tutorial. Many art videos have only music.\n\nRespond with JSON only, no markdown:\n{\"talks_in_videos\": false, \"audio_description\": \"\", \"speech_quote\": \"N/A\", \"speaks_english\": false, \"videos_with_speech\": 0, \"voice_potential\": 0, \"teaching_potential\": 0, \"content_quality\": 0, \"brand_fit\": 0, \"overall_ugc_score\": 0, \"video_summary\": \"\", \"ugc_reasoning\": \"\", \"recommendation\": \"\", \"next_steps\": \"\"}`\n});\n\nreturn {\n  json: {\n    skip_gemini: false,\n    requestBody: {\n      contents: [{\n        parts: parts\n      }]\n    },\n    username: item.username\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        800
      ],
      "id": "1353cbf4-02f3-4520-97e3-5208c9a81820",
      "name": "Prepare Gemini Input"
    },
    {
      "parameters": {
        "jsCode": "// Parse Gemini Response \u2014 Phase 2 Code Node\n// Extracts JSON scores from Gemini response\n// Includes validation to catch:\n//   1. \"No video provided\" responses (Gemini analyzed captions only)\n//   2. Hallucinations (talks_in_videos=true but audio contradicts)\n//\n// n8n WIRING:\n// Gemini Video Analysis \u2192 this node \u2192 Log to AI Logs + Update Profile Status\n\nconst geminiResponse = $input.item.json;\nconst loopData = $('Loop Profiles').item.json;\n\n// Extract the text from Gemini response\nlet text = geminiResponse.candidates[0].content.parts[0].text;\n\n// Remove markdown code blocks if present\ntext = text.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n\n// Parse the JSON\nlet parsed;\ntry {\n  parsed = JSON.parse(text);\n} catch (e) {\n  parsed = {\n    talks_in_videos: false,\n    speaks_english: false,\n    voice_potential: 0,\n    teaching_potential: 0,\n    content_quality: 0,\n    brand_fit: 0,\n    overall_ugc_score: 0,\n    video_summary: \"Failed to parse response\",\n    ugc_reasoning: \"Parse error\",\n    recommendation: \"MAYBE\",\n    next_steps: \"Manual review needed\",\n    audio_description: \"\",\n    speech_quote: \"N/A\",\n    videos_with_speech: 0\n  };\n}\n\n// \u2500\u2500 VALIDATION 1: Detect \"no video provided\" responses \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// If Gemini didn't receive the actual video, it analyzes based on captions only.\n// These responses contain telltale phrases in audio_description.\nconst audioDesc = (parsed.audio_description || '').toLowerCase();\nconst noVideoPatterns = [\n  'no video provided',\n  'no audio provided',\n  'no audio information',\n  'based on the caption',\n  'no video available',\n  'without video',\n  'cannot analyze'\n];\nconst noVideoReceived = noVideoPatterns.some(pattern => audioDesc.includes(pattern));\n\nlet statusOverride = 'VIDEO_ANALYZED';\nlet validationNote = '';\n\nif (noVideoReceived) {\n  // Gemini didn't receive the video \u2014 zero out scores, mark as failed\n  statusOverride = 'ANALYSIS_FAILED';\n  validationNote = '[NO VIDEO RECEIVED] ';\n  parsed.talks_in_videos = false;\n  parsed.speaks_english = false;\n  parsed.voice_potential = 0;\n  parsed.teaching_potential = 0;\n  parsed.content_quality = 0;\n  parsed.brand_fit = 0;\n  parsed.overall_ugc_score = 0;\n  parsed.videos_with_speech = 0;\n  parsed.speech_quote = 'N/A';\n  parsed.recommendation = 'NO';\n  parsed.ugc_reasoning = 'Analysis invalid \u2014 Gemini did not receive video files. Needs re-analysis.';\n}\n\n// \u2500\u2500 VALIDATION 2: Detect hallucinations \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// If talks_in_videos=true but audio_description has no speech-related words,\n// the model is likely hallucinating speech.\nif (!noVideoReceived && parsed.talks_in_videos === true) {\n  const speechKeywords = ['speech', 'speak', 'talk', 'narrat', 'voice', 'explain', 'says', 'said', 'comment', 'discuss', 'instruct', 'teach', 'verbal', 'word'];\n  const hasSpeeechEvidence = speechKeywords.some(kw => audioDesc.includes(kw));\n\n  if (!hasSpeeechEvidence) {\n    // Audio description contradicts talks_in_videos \u2014 correct it\n    validationNote = '[CORRECTED: talks_in_videos overridden to false \u2014 audio_description has no speech evidence] ';\n    parsed.talks_in_videos = false;\n    parsed.speaks_english = false;\n    parsed.videos_with_speech = 0;\n    parsed.speech_quote = 'N/A';\n  }\n}\n\nreturn {\n  json: {\n    // Original profile data\n    username: loopData.username,\n    reel_url: loopData.reel_1_url,\n\n    // Status (VIDEO_ANALYZED or ANALYSIS_FAILED)\n    status_override: statusOverride,\n\n    // Parsed video scores (may be zeroed/corrected by validation)\n    talks_in_videos: parsed.talks_in_videos || false,\n    speaks_english: parsed.speaks_english || false,\n    voice_potential: parsed.voice_potential || 0,\n    teaching_potential: parsed.teaching_potential || 0,\n    content_quality: parsed.content_quality || 0,\n    brand_fit: parsed.brand_fit || 0,\n    overall_ugc_score: parsed.overall_ugc_score || 0,\n\n    // Hallucination detection fields\n    audio_description: validationNote + (parsed.audio_description || \"\"),\n    speech_quote: parsed.speech_quote || \"N/A\",\n    videos_with_speech: parsed.videos_with_speech || 0,\n\n    // Text fields\n    video_summary: parsed.video_summary || \"\",\n    ugc_reasoning: parsed.ugc_reasoning || \"\",\n    recommendation: parsed.recommendation || \"MAYBE\",\n    next_steps: parsed.next_steps || \"\",\n\n    // Keep raw response for logging\n    raw_response: geminiResponse\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1460,
        800
      ],
      "id": "c51ca7c0-12f0-475e-91ce-6ab57cd09cde",
      "name": "Parse Gemini Response"
    },
    {
      "parameters": {
        "amount": 90
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        580,
        800
      ],
      "id": "c3da5d1e-b6e3-4a03-abcc-83a4b82bba32",
      "name": "Wait for Gemini",
      "webhookId": "0f6a3d96-133e-449c-b87a-f1d9e773e4a6"
    },
    {
      "parameters": {
        "url": "={{ $('Build Storage URLs').item.json.reel_1_download_url }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_ROLE_KEY }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          },
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -740,
        800
      ],
      "id": "9056baf0-459f-4cd3-8e06-da46a6149921",
      "name": "Download Reel 1",
      "alwaysOutputData": false,
      "executeOnce": false,
      "retryOnFail": false,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/upload/v1beta/files?key=AIzaSyAA63nf0G3Wc4HMhFUL8EWGHX0RqBQyyCs",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Goog-Upload-Command",
              "value": "start, upload, finalize"
            },
            {
              "name": "X-Goog-Upload-Header-Content-Length",
              "value": "={{ $binary.data.fileSize }}"
            },
            {
              "name": "X-Goog-Upload-Header-Content-Type",
              "value": "video/mp4"
            },
            {
              "name": "Content-Type",
              "value": "video/mp4"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "data",
        "options": {
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -520,
        800
      ],
      "id": "f0b79cb8-387d-4a38-be8d-56202bb7e8d0",
      "name": "Upload Reel 1",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "={{ $('Build Storage URLs').item.json.reel_3_download_url }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_ROLE_KEY }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          },
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        140,
        800
      ],
      "id": "8ba7d35a-60f6-4e8f-ae40-0869489df924",
      "name": "Download Reel 3",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/upload/v1beta/files?key=AIzaSyAA63nf0G3Wc4HMhFUL8EWGHX0RqBQyyCs",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Goog-Upload-Command",
              "value": "start, upload, finalize"
            },
            {
              "name": "X-Goog-Upload-Header-Content-Length",
              "value": "={{ $binary.data.fileSize }}"
            },
            {
              "name": "X-Goog-Upload-Header-Content-Type",
              "value": "video/mp4"
            },
            {
              "name": "Content-Type",
              "value": "video/mp4"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "data",
        "options": {
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        360,
        800
      ],
      "id": "a058417e-4c24-4f8c-9822-6652de484160",
      "name": "Upload Reel 3",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "={{ $('Build Storage URLs').item.json.reel_2_download_url }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_ROLE_KEY }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          },
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -300,
        800
      ],
      "id": "a9ef592a-b649-4ad2-b8a0-bf01e973319a",
      "name": "Download Reel 2",
      "retryOnFail": false,
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/upload/v1beta/files?key=AIzaSyAA63nf0G3Wc4HMhFUL8EWGHX0RqBQyyCs",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Goog-Upload-Command",
              "value": "start, upload, finalize"
            },
            {
              "name": "X-Goog-Upload-Header-Content-Length",
              "value": "={{ $binary.data.fileSize }}"
            },
            {
              "name": "X-Goog-Upload-Header-Content-Type",
              "value": "video/mp4"
            },
            {
              "name": "Content-Type",
              "value": "video/mp4"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "data",
        "options": {
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -80,
        800
      ],
      "id": "c72c7330-3f33-409d-9832-9cb5a71ee53a",
      "name": "Upload Reel 2",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "0ef1439e-a71c-4de3-a4f6-35a72d338b56",
              "leftValue": "={{ $json._skip }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        800,
        300
      ],
      "id": "e38f01f7-4217-41fe-84fb-bd5a79008120",
      "name": "Has Reels?"
    },
    {
      "parameters": {
        "amount": 2
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        140,
        300
      ],
      "id": "8318ed40-450b-4828-941b-8f586a0f7b3a",
      "name": "Wait for Apify",
      "webhookId": "265960d0-02dc-4cc0-b9df-554b0a230c93"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Download & Store Reels to Supabase Storage\n// Run AFTER \"Save to DB\" node in Phase 1 while CDN URLs are still fresh\n//\n// n8n WIRING:\n// Save DB \u2192 this node \u2192 Done\n//\n// This node downloads each reel from Instagram CDN and uploads to Supabase Storage,\n// then updates the profile row with the storage paths.\n\nconst https = require('https');\nconst http = require('http');\nconst profile = $input.item.json;\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\nconst BUCKET = 'reel-videos';\n\nconst results = {\n  username: profile.username,\n  reel_1_storage_path: null,\n  reel_2_storage_path: null,\n  reel_3_storage_path: null,\n  videos_downloaded: false,\n  downloaded_count: 0,\n  errors: []\n};\n\nfunction downloadUrl(url) {\n  return new Promise((resolve, reject) => {\n    const client = url.startsWith('https') ? https : http;\n    client.get(url, { headers: { 'User-Agent': 'Mozilla/5.0' } }, (res) => {\n      // Handle redirects\n      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n        return downloadUrl(res.headers.location).then(resolve).catch(reject);\n      }\n      if (res.statusCode !== 200) {\n        return reject(new Error(`Download failed: ${res.statusCode}`));\n      }\n      const chunks = [];\n      res.on('data', (chunk) => chunks.push(chunk));\n      res.on('end', () => resolve(Buffer.concat(chunks)));\n      res.on('error', reject);\n    }).on('error', reject);\n  });\n}\n\nfunction uploadToStorage(storagePath, videoBuffer) {\n  return new Promise((resolve, reject) => {\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: `/storage/v1/object/${BUCKET}/${storagePath}`,\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'video/mp4',\n        'x-upsert': 'true',\n        'Content-Length': videoBuffer.length\n      }\n    };\n    const req = https.request(options, (res) => {\n      let data = '';\n      res.on('data', (chunk) => data += chunk);\n      res.on('end', () => {\n        if (res.statusCode >= 200 && res.statusCode < 300) {\n          resolve(data);\n        } else {\n          reject(new Error(`Upload failed: ${res.statusCode} ${data}`));\n        }\n      });\n    });\n    req.on('error', reject);\n    req.write(videoBuffer);\n    req.end();\n  });\n}\n\nfunction supabasePatch(path, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: 'PATCH',\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal',\n        'Content-Length': Buffer.byteLength(data)\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data: responseData }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\nasync function downloadAndStore(reelUrl, reelNumber) {\n  if (!reelUrl) return null;\n\n  try {\n    const videoBuffer = await downloadUrl(reelUrl);\n    const storagePath = `${profile.username}/reel_${reelNumber}.mp4`;\n    await uploadToStorage(storagePath, videoBuffer);\n    return storagePath;\n  } catch (err) {\n    results.errors.push(`Reel ${reelNumber}: ${err.message}`);\n    return null;\n  }\n}\n\n// Download all 3 reels (sequential to avoid overwhelming Instagram)\nconst path1 = await downloadAndStore(profile.reel_1_url, 1);\nconst path2 = await downloadAndStore(profile.reel_2_url, 2);\nconst path3 = await downloadAndStore(profile.reel_3_url, 3);\n\nresults.reel_1_storage_path = path1;\nresults.reel_2_storage_path = path2;\nresults.reel_3_storage_path = path3;\nresults.downloaded_count = [path1, path2, path3].filter(Boolean).length;\nresults.videos_downloaded = results.downloaded_count > 0;\n\n// Update profile in Supabase with storage paths\nif (results.videos_downloaded) {\n  try {\n    await supabasePatch(\n      `/rest/v1/profiles?username=eq.${encodeURIComponent(profile.username)}`,\n      {\n        reel_1_storage_path: path1,\n        reel_2_storage_path: path2,\n        reel_3_storage_path: path3,\n        videos_downloaded: true\n      }\n    );\n  } catch (e) {\n    console.log('Failed to update storage paths:', e.message);\n  }\n}\n\nreturn {\n  json: {\n    ...profile,\n    ...results\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1680,
        300
      ],
      "id": "634502ef-7751-4ad5-842c-73cd84b19c66",
      "name": "Download & Store Reels"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const profile = $input.item.json;\nconst SUPABASE_URL = 'https://gwytongsbnciyulphcjv.supabase.co';\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction buildDownloadUrl(storagePath, cdnFallback) {\n  if (storagePath) {\n    return `${SUPABASE_URL}/storage/v1/object/public/reel-videos/${storagePath}`;\n  }\n  return cdnFallback || '';\n}\n\nreturn {\n  json: {\n    ...profile,\n    reel_1_download_url: buildDownloadUrl(profile.reel_1_storage_path, profile.reel_1_url),\n    reel_2_download_url: buildDownloadUrl(profile.reel_2_storage_path, profile.reel_2_url),\n    reel_3_download_url: buildDownloadUrl(profile.reel_3_storage_path, profile.reel_3_url),\n    using_storage: !!(profile.reel_1_storage_path || profile.reel_2_storage_path || profile.reel_3_storage_path)\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -960,
        800
      ],
      "id": "9401c890-9e03-4b58-afae-9911c6c25844",
      "name": "Build Storage URLs"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "skip-check",
              "leftValue": "={{ $json.skip_gemini }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1020,
        800
      ],
      "id": "62a7446d-3c09-4f78-823b-b0c9ac8eb63a",
      "name": "Skip Check"
    },
    {
      "parameters": {
        "jsCode": "const https = require('https');\nconst item = $input.item.json;\nconst loopItem = $('Loop Profiles').item.json;\nconst SUPABASE_URL = 'https://gwytongsbnciyulphcjv.supabase.co';\nconst SUPABASE_KEY = $env.SUPABASE_SERVICE_ROLE_KEY || 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabaseRequest(method, path, body) {\n  return new Promise((resolve, reject) => {\n    const data = body ? JSON.stringify(body) : '';\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: method,\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal',\n        'Content-Length': Buffer.byteLength(data)\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data: responseData }));\n    });\n    req.on('error', reject);\n    if (data) req.write(data);\n    req.end();\n  });\n}\n\n// Determine status based on whether videos exist in storage\n// If videos are in storage, mark as HUMAN_REVIEWED so it can be retried\n// If no videos at all, mark as DOWNLOAD_FAILED (needs re-scrape)\nconst hasVideosInStorage = loopItem.videos_downloaded === true && loopItem.reel_1_storage_path;\nconst newStatus = hasVideosInStorage ? 'HUMAN_REVIEWED' : 'DOWNLOAD_FAILED';\n\n// Log to ai_logs\ntry {\n  await supabaseRequest('POST', '/rest/v1/ai_logs', {\n    profile_username: item.username,\n    workflow_name: 'WF-Video-Analysis',\n    model_used: 'SKIPPED',\n    output_raw: item.skip_reason || 'No videos uploaded',\n    audit_status: hasVideosInStorage ? 'skipped_retry_later' : 'skipped_no_videos',\n    prompt_version: 1\n  });\n} catch (e) {\n  console.log('Failed to log to ai_logs:', e.message);\n}\n\n// Log to skipped_profiles for audit\ntry {\n  await supabaseRequest('POST', '/rest/v1/skipped_profiles', {\n    username: item.username,\n    skip_reason: hasVideosInStorage\n      ? 'GEMINI_UPLOAD_FAILED_HAS_STORAGE'\n      : (item.skip_reason || 'NO_VIDEOS_UPLOADED'),\n    workflow_stage: 'Phase2-VideoAnalysis',\n    source: loopItem.source || 'unknown'\n  });\n} catch (e) {\n  console.log('Failed to log skip:', e.message);\n}\n\n// Update profile status\ntry {\n  await supabaseRequest('PATCH',\n    `/rest/v1/profiles?username=eq.${encodeURIComponent(item.username)}`, {\n    status: newStatus\n  });\n} catch (e) {\n  console.log('Failed to update profile status:', e.message);\n}\n\nreturn {\n  json: {\n    username: item.username,\n    action: 'skipped',\n    reason: item.skip_reason,\n    new_status: newStatus,\n    has_storage: hasVideosInStorage\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        650
      ],
      "id": "47e7ed23-0d9f-469f-a45e-f6502ff0b09b",
      "name": "Handle Skipped Profile"
    },
    {
      "parameters": {
        "jsCode": "// Pre-Filter Known Profiles \u2014 Phase 1 Code Node\n// Removes usernames already in `profiles` or `seen_profiles` BEFORE sending to Apify.\n// Saves Apify credits by not re-scraping known profiles.\n// Also logs skipped profiles to `skipped_profiles` table for audit.\n//\n// n8n WIRING:\n// Dedupe Profiles \u2192 this node \u2192 Wait1 \u2192 Run an Actor (Apify)\n\nconst https = require('https');\nconst items = $input.all();\nconst usernames = items.map(i => i.json.username).filter(Boolean);\n\nif (usernames.length === 0) return [];\n\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabaseRequest(method, path, body) {\n  return new Promise((resolve, reject) => {\n    const data = body ? JSON.stringify(body) : '';\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: method,\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal',\n        'Content-Length': Buffer.byteLength(data)\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => {\n        try {\n          resolve({ status: res.statusCode, data: JSON.parse(responseData) });\n        } catch (e) {\n          resolve({ status: res.statusCode, data: responseData });\n        }\n      });\n    });\n    req.on('error', reject);\n    if (data) req.write(data);\n    req.end();\n  });\n}\n\n// Build comma-separated list for Supabase IN filter\nconst usernameList = usernames.map(u => encodeURIComponent(u)).join(',');\n\n// Check profiles table\nlet existingUsernames = new Set();\ntry {\n  const res = await supabaseRequest('GET', `/rest/v1/profiles?username=in.(${usernameList})&select=username`);\n  if (Array.isArray(res.data)) {\n    res.data.forEach(p => existingUsernames.add(p.username));\n  }\n} catch (e) {\n  console.log('Failed to query profiles:', e.message);\n}\n\n// Check seen_profiles table\ntry {\n  const res = await supabaseRequest('GET', `/rest/v1/seen_profiles?username=in.(${usernameList})&select=username`);\n  if (Array.isArray(res.data)) {\n    res.data.forEach(p => existingUsernames.add(p.username));\n  }\n} catch (e) {\n  // seen_profiles may not exist yet \u2014 continue\n  console.log('seen_profiles check skipped:', e.message);\n}\n\nconst newItems = items.filter(i => !existingUsernames.has(i.json.username));\n\n// \u2500\u2500 Log skipped profiles to skipped_profiles table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nconst skippedItems = items.filter(i => existingUsernames.has(i.json.username));\nif (skippedItems.length > 0) {\n  const skippedRows = skippedItems.map(i => ({\n    username: i.json.username,\n    skip_reason: 'ALREADY_KNOWN',\n    workflow_stage: 'Phase1-PreFilter',\n    source: i.json.source || 'unknown'\n  }));\n\n  try {\n    await supabaseRequest('POST', '/rest/v1/skipped_profiles', skippedRows);\n  } catch (e) {\n    console.log('Failed to log skipped profiles:', e.message);\n  }\n}\n\n// \u2500\u2500 Limit batch size to control Apify + Claude costs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nconst MAX_PROFILES = 20;\nconst limitedItems = newItems.slice(0, MAX_PROFILES);\n\nif (newItems.length > MAX_PROFILES) {\n  // Log the ones we're deferring\n  const deferredItems = newItems.slice(MAX_PROFILES);\n  const deferredRows = deferredItems.map(i => ({\n    username: i.json.username,\n    skip_reason: 'BATCH_LIMIT',\n    workflow_stage: 'Phase1-PreFilter',\n    source: i.json.source || 'unknown'\n  }));\n  try {\n    await supabaseRequest('POST', '/rest/v1/skipped_profiles', deferredRows);\n  } catch (e) {\n    console.log('Failed to log deferred profiles:', e.message);\n  }\n}\n\n// \u2500\u2500 Immediately mark these profiles as seen to prevent duplicate processing \u2500\u2500\n// This is critical: without this, concurrent runs will both pick up the same profiles\nif (limitedItems.length > 0) {\n  const seenRows = limitedItems.map(i => ({\n    username: i.json.username,\n    source: i.json.source || 'unknown',\n    source_type: i.json.sourceType || 'competitor_follower',\n    followers: i.json.followers || 0,\n    rejection_reason: 'IN_PROGRESS'\n  }));\n  try {\n    await supabaseRequest('POST', '/rest/v1/seen_profiles?on_conflict=username', seenRows);\n  } catch (e) {\n    console.log('Failed to mark profiles as seen:', e.message);\n  }\n}\n\nconsole.log(`Pre-filter: ${usernames.length} total, ${existingUsernames.size} known, ${newItems.length} new, ${limitedItems.length} sending (max ${MAX_PROFILES})`);\n\nreturn limitedItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        300
      ],
      "id": "8b097789-dcab-4fae-9760-27ebbd772274",
      "name": "Pre-Filter Known Profiles"
    },
    {
      "parameters": {
        "jsCode": "// Save to Seen Profiles \u2014 Phase 1 Code Node\n// Saves rejected profiles (failed filter) to seen_profiles table\n// so they don't get re-scraped on future runs.\n// Also logs to skipped_profiles table for audit trail.\n//\n// n8n WIRING:\n// IF node [FALSE branch, _skip=true] \u2192 this node \u2192 Done\n\nconst https = require('https');\nconst items = $input.all();\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabaseRequest(method, path, body, extraHeaders) {\n  return new Promise((resolve, reject) => {\n    const data = body ? JSON.stringify(body) : '';\n    const hdrs = {\n      'apikey': SUPABASE_KEY,\n      'Authorization': `Bearer ${SUPABASE_KEY}`,\n      'Content-Type': 'application/json',\n      'Prefer': 'return=minimal',\n      'Content-Length': Buffer.byteLength(data),\n      ...extraHeaders\n    };\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: method,\n      headers: hdrs\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data: responseData }));\n    });\n    req.on('error', reject);\n    if (data) req.write(data);\n    req.end();\n  });\n}\n\nlet saved = 0;\n\nfor (const item of items) {\n  const data = item.json;\n  if (!data.username) continue;\n\n  try {\n    await supabaseRequest('POST', '/rest/v1/seen_profiles', {\n      username: data.username,\n      source: data.source || null,\n      source_type: data.source_type || 'tagged',\n      followers: data.followers || null,\n      rejection_reason: data.reason || 'unknown'\n    }, { 'Prefer': 'return=minimal,resolution=merge-duplicates' });\n    saved++;\n  } catch (e) {\n    console.log(`Failed to save ${data.username}:`, e.message);\n  }\n\n  // Also log to skipped_profiles for audit\n  try {\n    await supabaseRequest('POST', '/rest/v1/skipped_profiles', {\n      username: data.username,\n      skip_reason: data.reason || 'BELOW_THRESHOLD',\n      workflow_stage: 'Phase1-FilterReels',\n      source: data.source || 'unknown'\n    });\n  } catch (e) {\n    console.log(`Failed to log skip for ${data.username}:`, e.message);\n  }\n}\n\nconsole.log(`Saved ${saved}/${items.length} rejected profiles to seen_profiles`);\n\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        500
      ],
      "id": "c8263d2d-6fd1-48af-bd98-a467115bdd23",
      "name": "Save Seen (No Reels)"
    },
    {
      "parameters": {
        "path": "phase-2",
        "options": {}
      },
      "id": "webhook-phase-2",
      "name": "Phase 2: Video Analysis",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1600,
        800
      ],
      "webhookId": "phase-2"
    },
    {
      "parameters": {
        "content": "## TRIGGERS\n\nPhase 1 \u2014 Discovery + Claude\nGET /webhook/phase-1\n\nPhase 2 \u2014 Gemini Video\nGET /webhook/phase-2\n\nEach phase has its own trigger.",
        "width": 350,
        "height": 850,
        "color": 1
      },
      "id": "54c0f034-437c-4027-b96d-3e8bdf6b6095",
      "name": "Triggers",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1700,
        100
      ]
    },
    {
      "parameters": {
        "content": "PHASE 1 \u2014 SCRAPE & COLLECT\nScrape competitor tagged posts via Apify. Extract unique usernames. Dedupe. Pre-filter known profiles. Full profile scrape.",
        "width": 2050,
        "height": 300,
        "color": 2
      },
      "id": "198665a0-b4d2-4f4e-a366-334959f403a6",
      "name": "P1: Scrape & Collect",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1450,
        150
      ]
    },
    {
      "parameters": {
        "content": "PHASE 1 \u2014 AI ANALYSIS\nFilter qualifying reels. Claude scores profile (niche, score, recommendation). Merge results.",
        "width": 700,
        "height": 300,
        "color": 4
      },
      "id": "cefcdf6b-f757-42f2-be56-b47e48416aff",
      "name": "P1: AI Analysis",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        650,
        150
      ]
    },
    {
      "parameters": {
        "content": "PHASE 1 \u2014 SAVE\nSave to Supabase profiles table. Download & store reels. Status \u2192 PENDING_REVIEW",
        "width": 700,
        "height": 300,
        "color": 6
      },
      "id": "552c49d3-b77a-4a36-8431-7de3d3b3dfe6",
      "name": "P1: Save",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1400,
        150
      ]
    },
    {
      "parameters": {
        "content": "PHASE 2 \u2014 FETCH & DOWNLOAD\nGet approved profiles. Loop through each. Build storage URLs. Download up to 3 reels. Upload to Supabase Storage.",
        "width": 1450,
        "height": 400,
        "color": 2
      },
      "id": "65bdb365-cf8c-4d53-9cd5-91eb210fde00",
      "name": "P2: Fetch & Download",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1450,
        550
      ]
    },
    {
      "parameters": {
        "content": "PHASE 2 \u2014 GEMINI ANALYSIS\nWait 90s for processing. Prepare input. Skip if already analyzed. Send videos to Gemini for speech, teaching, production quality scoring.",
        "width": 1200,
        "height": 400,
        "color": 5
      },
      "id": "63931c20-052b-459f-8af3-0d66d98e2603",
      "name": "P2: Gemini Analysis",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        50,
        550
      ]
    },
    {
      "parameters": {
        "content": "PHASE 2 \u2014 SAVE RESULTS\nParse Gemini response. Log to ai_logs. Update profile with video scores. Status \u2192 VIDEO_ANALYZED",
        "width": 800,
        "height": 400,
        "color": 6
      },
      "id": "03118c72-d8ac-43bc-8110-44045e3f4dcd",
      "name": "P2: Save Results",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1300,
        550
      ]
    }
  ],
  "connections": {
    "Collect Batch": {
      "main": [
        [
          {
            "node": "Aggregate All",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate All": {
      "main": [
        [
          {
            "node": "Dedupe Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dedupe Profiles": {
      "main": [
        [
          {
            "node": "Pre-Filter Known Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Reels": {
      "main": [
        [
          {
            "node": "Has Reels?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Claude Analysis": {
      "main": [
        [
          {
            "node": "Merge Claude Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Claude Results": {
      "main": [
        [
          {
            "node": "Save DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save DB": {
      "main": [
        [
          {
            "node": "Download & Store Reels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apify: Tagged Posts": {
      "main": [
        [
          {
            "node": "Extract Profiles1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Settings1": {
      "main": [
        [
          {
            "node": "Apify: Tagged Posts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Profiles1": {
      "main": [
        [
          {
            "node": "Collect Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run an Actor and get dataset": {
      "main": [
        [
          {
            "node": "Filter Reels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get COLLABORATE Profiles": {
      "main": [
        [
          {
            "node": "Loop Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Profiles": {
      "main": [
        [
          {
            "node": "Phase 2 Done",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Storage URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini Video Analysis": {
      "main": [
        [
          {
            "node": "Parse Gemini Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log to AI Logs": {
      "main": [
        [
          {
            "node": "Update Profile Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Profile Status": {
      "main": [
        [
          {
            "node": "Loop Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Gemini Input": {
      "main": [
        [
          {
            "node": "Skip Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Gemini Response": {
      "main": [
        [
          {
            "node": "Log to AI Logs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Gemini": {
      "main": [
        [
          {
            "node": "Prepare Gemini Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Reel 1": {
      "main": [
        [
          {
            "node": "Upload Reel 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Reel 1": {
      "main": [
        [
          {
            "node": "Download Reel 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Reel 3": {
      "main": [
        [
          {
            "node": "Upload Reel 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Reel 3": {
      "main": [
        [
          {
            "node": "Wait for Gemini",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Reel 2": {
      "main": [
        [
          {
            "node": "Upload Reel 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Reel 2": {
      "main": [
        [
          {
            "node": "Download Reel 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Reels?": {
      "main": [
        [
          {
            "node": "Claude Analysis",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Save Seen (No Reels)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Apify": {
      "main": [
        [
          {
            "node": "Run an Actor and get dataset",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download & Store Reels": {
      "main": [
        [
          {
            "node": "Phase 1 Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Phase 2 Done": {
      "main": [
        []
      ]
    },
    "Build Storage URLs": {
      "main": [
        [
          {
            "node": "Download Reel 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Check": {
      "main": [
        [
          {
            "node": "Handle Skipped Profile",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Gemini Video Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Skipped Profile": {
      "main": [
        [
          {
            "node": "Loop Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pre-Filter Known Profiles": {
      "main": [
        [
          {
            "node": "Wait for Apify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Phase 1: Discovery": {
      "main": [
        [
          {
            "node": "Settings1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Phase 2: Video Analysis": {
      "main": [
        [
          {
            "node": "Get COLLABORATE Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false,
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "0ebdf18a5e1f334ec513fc69592108daed62ea1dd9c50547de268caaf703f432"
  },
  "pinData": {},
  "versionId": "5af9bdc7-d3ca-448e-bd01-14f719aeaddc",
  "activeVersionId": "eae9169a-1009-4cca-b206-d16115f8ef9d",
  "versionCounter": 119,
  "triggerCount": 2,
  "shared": [
    {
      "updatedAt": "2026-01-26T13:37:27.938Z",
      "createdAt": "2026-01-26T13:37:27.938Z",
      "role": "workflow:owner",
      "workflowId": "4Nqc0B8DU_OcFoxfK3tMD",
      "projectId": "gzzn94dP4ic17og7",
      "project": {
        "updatedAt": "2026-01-16T08:37:54.576Z",
        "createdAt": "2026-01-16T08:21:06.380Z",
        "id": "gzzn94dP4ic17og7",
        "name": "Studio SEM <sem.optimise@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "812ddc87-0a2d-4632-8631-19ad0cbbb5fe",
        "projectRelations": [
          {
            "updatedAt": "2026-01-16T08:21:06.380Z",
            "createdAt": "2026-01-16T08:21:06.380Z",
            "userId": "812ddc87-0a2d-4632-8631-19ad0cbbb5fe",
            "projectId": "gzzn94dP4ic17og7",
            "user": {
              "updatedAt": "2026-02-17T08:00:26.000Z",
              "createdAt": "2026-01-16T08:21:05.660Z",
              "id": "812ddc87-0a2d-4632-8631-19ad0cbbb5fe",
              "email": "sem.optimise@gmail.com",
              "firstName": "Studio",
              "lastName": "SEM",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2026-01-16T08:38:00.375Z",
                "personalization_survey_n8n_version": "2.3.5"
              },
              "settings": {
                "userActivated": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "4Nqc0B8DU_OcFoxfK3tMD",
                "userActivatedAt": 1771264128260
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-16",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-02-17T07:47:05.877Z",
    "createdAt": "2026-02-17T07:47:05.877Z",
    "versionId": "eae9169a-1009-4cca-b206-d16115f8ef9d",
    "workflowId": "4Nqc0B8DU_OcFoxfK3tMD",
    "nodes": [
      {
        "parameters": {
          "operation": "append",
          "documentId": {
            "__rl": true,
            "value": "1HqsIaxnz3elGDOAd4njxkUkFqF-OBljY-bkYWMtdWvM",
            "mode": "list",
            "cachedResultName": "21Draw UGC Candidates",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1HqsIaxnz3elGDOAd4njxkUkFqF-OBljY-bkYWMtdWvM/edit?usp=drivesdk"
          },
          "sheetName": {
            "__rl": true,
            "value": "gid=0",
            "mode": "list",
            "cachedResultName": "Sheet1",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1HqsIaxnz3elGDOAd4njxkUkFqF-OBljY-bkYWMtdWvM/edit#gid=0"
          },
          "columns": {
            "mappingMode": "defineBelow",
            "value": {
              "Handle": "={{ $json.username }}",
              "Followers": "={{ $json.followers }}",
              "Engagement %": "={{ $json.engagement_rate }}",
              "Profile Score": "={{ $json.profile_score }}",
              "Niche Score": "={{ $json.niche_relevance }}",
              "Engagement Score": "={{ $json.engagement_quality }}",
              "Style": "={{ $json.content_themes }}",
              "Art Content": "={{ $json.has_art_content }}",
              "Avg Duration": "={{ $json.avg_duration }}",
              "Source": "={{ $json.source }}",
              "Top Video 1": "={{ $json.reel_1_url }}",
              "Top Video 2": "={{ $json.reel_2_url }}",
              "Top Video 3": "={{ $json.reel_3_url }}",
              "AI Notes": "={{ $json.reasoning }}",
              "Review Notes": "={{ $json.manual_review_notes }}",
              "Priority": "={{ $json.recommendation }}",
              "Status": "=PENDING_REVIEW",
              "Date Added": "={{ $json.analyzed_at }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "Handle",
                "displayName": "Handle",
                "type": "string"
              },
              {
                "id": "Followers",
                "displayName": "Followers",
                "type": "string"
              },
              {
                "id": "Engagement %",
                "displayName": "Engagement %",
                "type": "string"
              },
              {
                "id": "Profile Score",
                "displayName": "Profile Score",
                "type": "string"
              },
              {
                "id": "Niche Score",
                "displayName": "Niche Score",
                "type": "string"
              },
              {
                "id": "Engagement Score",
                "displayName": "Engagement Score",
                "type": "string"
              },
              {
                "id": "Style",
                "displayName": "Style",
                "type": "string"
              },
              {
                "id": "Art Content",
                "displayName": "Art Content",
                "type": "string"
              },
              {
                "id": "Avg Duration",
                "displayName": "Avg Duration",
                "type": "string"
              },
              {
                "id": "Source",
                "displayName": "Source",
                "type": "string"
              },
              {
                "id": "Top Video 1",
                "displayName": "Top Video 1",
                "type": "string"
              },
              {
                "id": "Top Video 2",
                "displayName": "Top Video 2",
                "type": "string"
              },
              {
                "id": "Top Video 3",
                "displayName": "Top Video 3",
                "type": "string"
              },
              {
                "id": "AI Notes",
                "displayName": "AI Notes",
                "type": "string"
              },
              {
                "id": "Review Notes",
                "displayName": "Review Notes",
                "type": "string"
              },
              {
                "id": "Priority",
                "displayName": "Priority",
                "type": "string"
              },
              {
                "id": "Status",
                "displayName": "Status",
                "type": "string"
              },
              {
                "id": "Date Added",
                "displayName": "Date Added",
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "15ddb581-454e-451d-b197-0eaf2bf21754",
        "name": "Sheets",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.5,
        "position": [
          832,
          0
        ],
        "notesInFlow": true,
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "VPNtyUhpYNjAijIt",
            "name": "Google Sheets account 2"
          }
        },
        "notes": "\u2705 Fixed: All columns mapped"
      },
      {
        "parameters": {},
        "id": "7a6e8ec9-063a-485f-b924-4cb85aaf9409",
        "name": "Start",
        "type": "n8n-nodes-base.manualTrigger",
        "typeVersion": 1,
        "position": [
          -6752,
          304
        ]
      },
      {
        "parameters": {
          "path": "run-pipeline",
          "responseMode": "onReceived",
          "options": {}
        },
        "id": "webhook-trigger-001",
        "name": "Webhook Trigger",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          -6752,
          104
        ],
        "webhookId": "run-pipeline"
      },
      {
        "parameters": {
          "jsCode": "// Collect profiles from this competitor batch\nreturn $input.all();"
        },
        "id": "c986d0d4-658f-49ac-95fe-e8c36adf89fd",
        "name": "Collect Batch",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -5872,
          304
        ]
      },
      {
        "parameters": {
          "aggregate": "aggregateAllItemData",
          "destinationFieldName": "allProfiles",
          "options": {}
        },
        "id": "d6868484-862b-4db8-b50a-f03ee54c9aad",
        "name": "Aggregate All",
        "type": "n8n-nodes-base.aggregate",
        "typeVersion": 1,
        "position": [
          -5616,
          304
        ],
        "notesInFlow": true,
        "notes": "Collects profiles from all competitors"
      },
      {
        "parameters": {
          "jsCode": "// Deduplicate profiles across all competitors\nconst data = $input.first().json;\nconst allProfiles = data.allProfiles || [];\nconst unique = new Map();\n\nfor (const p of allProfiles) {\n  if (!p.username) continue;\n  if (!unique.has(p.username)) {\n    unique.set(p.username, p);\n  }\n}\n\nconst deduped = Array.from(unique.values());\nconsole.log(`Total unique profiles after deduplication: ${deduped.length}`);\n\nreturn deduped.map(p => ({ json: p }));"
        },
        "id": "7d6e46d9-842e-4931-84cb-4c473fb6a9ca",
        "name": "Dedupe Profiles",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -5408,
          304
        ]
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// Filter Reels: Extract top 3 reels, calculate engagement, skip invalid profiles\nconst profile = $input.item.json;\nconst settings = $('Settings1').first().json;\n\n// Source info is passed through from Pre-Filter Known Profiles \u2192 Apify\n// Fall back to 'unknown' if not available\nconst preFiltered = $('Pre-Filter Known Profiles').all();\nconst sourceMatch = preFiltered.find(p => p.json.username === profile.username);\nconst sourceData = sourceMatch?.json || { source: 'unknown', sourceType: 'tagged' };\nconst followers = Number(profile.followersCount) || 0;\n\nif (!profile.followersCount || followers === 0) {\n  return { json: { _skip: true, username: profile.username || 'unknown', reason: 'private_or_empty' } };\n}\n\n// Skip profiles outside follower range (2k-150k)\nif (followers < settings.minFollowers || followers > settings.maxFollowers) {\n  return { json: { _skip: true, username: profile.username, followers: followers, reason: 'outside_follower_range' } };\n}\n\nconst posts = profile.latestPosts || [];\n\nif (posts.length === 0) {\n  return { json: { _skip: true, username: profile.username || 'unknown', reason: 'no_posts_returned' } };\n}\n\nconst reels = posts.filter(post => {\n  const isClip = (post.productType === 'clips');\n  const isVideo = (post.type === 'Video' && post.productType !== 'igtv');\n  if (post.videoDuration) {\n    const dur = Number(post.videoDuration);\n    if (dur < 15 || dur > 90) return false;\n  }\n  return isClip || isVideo;\n});\n\nlet qualifyingReels = reels;\nif (qualifyingReels.length === 0) {\n  qualifyingReels = posts.filter(post =>\n    post.type === 'Video' || post.productType === 'clips' || post.productType === 'igtv'\n  );\n}\n\nqualifyingReels.sort((a, b) => {\n  const engA = (Number(a.likesCount) || 0) + (Number(a.commentsCount) || 0);\n  const engB = (Number(b.likesCount) || 0) + (Number(b.commentsCount) || 0);\n  return engB - engA;\n});\n\nconst topReels = qualifyingReels.slice(0, 3);\nlet engagement_rate = 0, avg_likes = 0, avg_comments = 0, avg_duration = 0;\n\nif (qualifyingReels.length > 0 && followers > 0) {\n  const totalLikes = qualifyingReels.reduce((sum, r) => sum + (Number(r.likesCount) || 0), 0);\n  const totalComments = qualifyingReels.reduce((sum, r) => sum + (Number(r.commentsCount) || 0), 0);\n  const totalDuration = qualifyingReels.reduce((sum, r) => sum + (Number(r.videoDuration) || 0), 0);\n  avg_likes = Math.round(totalLikes / qualifyingReels.length);\n  avg_comments = Math.round(totalComments / qualifyingReels.length);\n  const reelsWithDur = qualifyingReels.filter(r => r.videoDuration);\n  avg_duration = reelsWithDur.length > 0 ? Math.round(totalDuration / reelsWithDur.length) : 0;\n  const avgEngagement = (totalLikes + totalComments) / qualifyingReels.length;\n  engagement_rate = Number(((avgEngagement / followers) * 100).toFixed(2));\n}\n\nif (qualifyingReels.length === 0 && posts.length > 0 && followers > 0) {\n  const totalLikes = posts.reduce((sum, p) => sum + (Number(p.likesCount) || 0), 0);\n  const totalComments = posts.reduce((sum, p) => sum + (Number(p.commentsCount) || 0), 0);\n  avg_likes = Math.round(totalLikes / posts.length);\n  avg_comments = Math.round(totalComments / posts.length);\n  engagement_rate = Number((((totalLikes + totalComments) / posts.length / followers) * 100).toFixed(2));\n}\n\nfunction getVideoUrl(post) {\n  if (post.videoUrl) return post.videoUrl;\n  return '';\n}\n\nfunction getPostUrl(post) {\n  if (post.url) return post.url;\n  if (post.shortCode) return `https://www.instagram.com/reel/${post.shortCode}/`;\n  return '';\n}\n\nreturn {\n  json: {\n    username: profile.username,\n    followers: followers,\n    bio: (profile.biography || '').substring(0, 500),\n    source: sourceData.source || 'unknown',\n    source_type: sourceData.sourceType || 'tagged',\n    has_art_content: true,\n    verified: profile.verified || false,\n    engagement_rate: engagement_rate,\n    avg_likes: avg_likes,\n    avg_comments: avg_comments,\n    avg_duration: avg_duration,\n    total_reels_found: qualifyingReels.length,\n\n    reel_1_url: topReels[0] ? getVideoUrl(topReels[0]) : '',\n    reel_1_post_url: topReels[0] ? getPostUrl(topReels[0]) : '',\n    reel_1_likes: topReels[0] ? (Number(topReels[0].likesCount) || 0) : 0,\n    reel_1_comments: topReels[0] ? (Number(topReels[0].commentsCount) || 0) : 0,\n    reel_1_duration: topReels[0] ? (Number(topReels[0].videoDuration) || 0) : 0,\n    reel_1_caption: topReels[0] ? (topReels[0].caption || '').substring(0, 300) : '',\n\n    reel_2_url: topReels[1] ? getVideoUrl(topReels[1]) : '',\n    reel_2_post_url: topReels[1] ? getPostUrl(topReels[1]) : '',\n    reel_2_likes: topReels[1] ? (Number(topReels[1].likesCount) || 0) : 0,\n    reel_2_comments: topReels[1] ? (Number(topReels[1].commentsCount) || 0) : 0,\n    reel_2_duration: topReels[1] ? (Number(topReels[1].videoDuration) || 0) : 0,\n    reel_2_caption: topReels[1] ? (topReels[1].caption || '').substring(0, 300) : '',\n\n    reel_3_url: topReels[2] ? getVideoUrl(topReels[2]) : '',\n    reel_3_post_url: topReels[2] ? getPostUrl(topReels[2]) : '',\n    reel_3_likes: topReels[2] ? (Number(topReels[2].likesCount) || 0) : 0,\n    reel_3_comments: topReels[2] ? (Number(topReels[2].commentsCount) || 0) : 0,\n    reel_3_duration: topReels[2] ? (Number(topReels[2].videoDuration) || 0) : 0,\n    reel_3_caption: topReels[2] ? (topReels[2].caption || '').substring(0, 300) : '',\n\n    analyzed_at: new Date().toISOString()\n  }\n};"
        },
        "id": "b411c782-4828-4eda-ae70-8c6c39854954",
        "name": "Filter Reels",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -4320,
          304
        ],
        "notesInFlow": true,
        "notes": "\u2705 Enhanced: engagement rate, hashtags, pre-filtering"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.anthropic.com/v1/messages",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "anthropicApi",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "anthropic-version",
                "value": "2023-06-01"
              },
              {
                "name": "content-type",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"model\": \"claude-sonnet-4-20250514\",\n  \"max_tokens\": 1024,\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": {{ JSON.stringify(\"Evaluate this Instagram creator for potential UGC partnership with 21Draw, an online art education platform.\\n\\nPROFILE DATA:\\nUsername: \" + $json.username + \"\\nFollowers: \" + $json.followers + \"\\nEngagement Rate: \" + ($json.engagement_rate || 0) + \"%\\nAvg Likes: \" + ($json.avg_likes || 0) + \"\\nAvg Comments: \" + ($json.avg_comments || 0) + \"\\nBio: \" + ($json.bio || \"\").replace(/[\\n\\r]/g, \" \") + \"\\nVerified: \" + $json.verified + \"\\nBusiness Category: \" + ($json.business_category || \"none\") + \"\\nTotal Reels Found: \" + ($json.total_reels_found || 0) + \"\\n\\nTOP REELS:\\nReel 1: \" + ($json.reel_1_url || \"none\") + \"\\n- Likes: \" + ($json.reel_1_likes || 0) + \" | Comments: \" + ($json.reel_1_comments || 0) + \"\\n- Caption: \" + ($json.reel_1_caption || \"\").replace(/[\\n\\r]/g, \" \") + \"\\n\\nReel 2: \" + ($json.reel_2_url || \"none\") + \"\\n- Likes: \" + ($json.reel_2_likes || 0) + \" | Comments: \" + ($json.reel_2_comments || 0) + \"\\n- Caption: \" + ($json.reel_2_caption || \"\").replace(/[\\n\\r]/g, \" \") + \"\\n\\nReel 3: \" + ($json.reel_3_url || \"none\") + \"\\n- Likes: \" + ($json.reel_3_likes || 0) + \" | Comments: \" + ($json.reel_3_comments || 0) + \"\\n- Caption: \" + ($json.reel_3_caption || \"\").replace(/[\\n\\r]/g, \" \") + \"\\n\\nEVALUATION CRITERIA:\\n- Niche relevance to art education (drawing, painting, sculpting, digital art, art tutorials)\\n- Engagement quality (likes, comments relative to followers)\\n- Content style fit for educational art platform\\n- Follower count (accounts with 5k+ followers in art niche are valuable)\\n- Even accounts with lower engagement rates should be COLLABORATE if they have strong art content and decent following\\n\\nRecommendation options:\\n- COLLABORATE: Strong fit, good metrics, art-relevant content\\n- REVIEW: Promising but needs manual review\\n- PASS: Not a good fit for 21Draw\\n- REJECT: Clearly unsuitable (spam, no art content, very low following)\\n\\nRespond with JSON only, no other text:\\n{\\\"niche_relevance\\\": 1-10, \\\"profile_score\\\": 1-10, \\\"recommendation\\\": \\\"COLLABORATE/REVIEW/PASS/REJECT\\\", \\\"reasoning\\\": \\\"your explanation here\\\"}\") }}\n    }\n  ]\n}",
          "options": {}
        },
        "id": "f080cdfb-72c3-4242-9669-84a50aa8f3ed",
        "name": "Claude Analysis",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -3696,
          288
        ],
        "notesInFlow": true,
        "retryOnFail": true,
        "waitBetweenTries": 5000,
        "credentials": {
          "anthropicApi": {
            "id": "6Ysrp6eyFvQXqLWi",
            "name": "Anthropic account"
          }
        },
        "notes": "\u2705 Fixed: Honest prompt about limitations",
        "maxTries": 5
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// Merge node: Combines Claude API response with profile data\n// AND logs the Claude call to ai_logs for audit trail\n// NOTE: Claude Analysis itself is an HTTP Request node (POST to api.anthropic.com)\n//       Model: claude-sonnet-4-20250514, max_tokens: 1024\n//       This code runs in the \"Merge\" node AFTER Claude returns its response.\n//\n// n8n WIRING:\n// Claude Analysis \u2192 this node \u2192 Save DB\n\nconst https = require('https');\nconst PROMPT_VERSION_CLAUDE = 1;\n\nconst index = $itemIndex;\nconst profileData = $('Has Reels?').all()[index];\nconst claudeResponse = $input.item.json;\n\nconst profile = profileData?.json || {};\nconst username = profile.username || null;\n\n// Extract raw response text and token usage\nconst rawText = claudeResponse.content?.[0]?.text || '{}';\nconst tokensUsed = (claudeResponse.usage?.input_tokens || 0) + (claudeResponse.usage?.output_tokens || 0);\n\n// Skip empty/failed Claude responses \u2014 don't save bad data to profiles\nif (!claudeResponse.content || tokensUsed === 0) {\n  // Still log the failure to ai_logs for debugging\n  const SUPABASE_KEY_EARLY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n  try {\n    const logData = JSON.stringify({\n      profile_username: username,\n      workflow_name: 'WF-Profile-Analysis',\n      model_used: 'claude-sonnet-4-20250514',\n      prompt_sent: `FAILED: ${username}`,\n      input_data: JSON.stringify({ username, followers: profile.followers }),\n      output_raw: JSON.stringify(claudeResponse).substring(0, 500),\n      output_parsed: '{}',\n      tokens_used: 0,\n      prompt_version: PROMPT_VERSION_CLAUDE\n    });\n    const https2 = require('https');\n    await new Promise((resolve) => {\n      const req = https2.request({\n        hostname: 'gwytongsbnciyulphcjv.supabase.co',\n        path: '/rest/v1/ai_logs',\n        method: 'POST',\n        headers: {\n          'apikey': SUPABASE_KEY_EARLY,\n          'Authorization': `Bearer ${SUPABASE_KEY_EARLY}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal',\n          'Content-Length': Buffer.byteLength(logData)\n        }\n      }, resolve);\n      req.on('error', resolve);\n      req.write(logData);\n      req.end();\n    });\n  } catch (e) { /* ignore */ }\n\n  return { json: { _skip: true, username: username, reason: 'empty_claude_response' } };\n}\n\nlet analysis = {};\ntry {\n  let text = rawText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n  analysis = JSON.parse(text);\n} catch (e) {\n  analysis = {\n    recommendation: 'REVIEW',\n    reasoning: 'Could not parse AI analysis',\n    profile_score: 5,\n    niche_relevance: 5\n  };\n}\n\n// \u2500\u2500 Log Claude call to ai_logs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabasePost(path, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: 'POST',\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal',\n        'Content-Length': Buffer.byteLength(data)\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data: responseData }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\ntry {\n  await supabasePost('/rest/v1/ai_logs', {\n    profile_username: username,\n    workflow_name: 'WF-Profile-Analysis',\n    model_used: 'claude-sonnet-4-20250514',\n    prompt_sent: `Evaluate creator: ${username} (${profile.followers} followers, ${profile.engagement_rate} engagement)`,\n    input_data: JSON.stringify({\n      username: username,\n      followers: profile.followers,\n      bio: profile.bio,\n      engagement_rate: profile.engagement_rate,\n      total_reels_found: profile.total_reels_found\n    }),\n    output_raw: rawText,\n    output_parsed: JSON.stringify(analysis),\n    tokens_used: tokensUsed,\n    prompt_version: PROMPT_VERSION_CLAUDE\n  });\n} catch (e) {\n  console.log('Failed to log Claude call to ai_logs:', e.message);\n}\n\nreturn {\n  json: {\n    username: username,\n    followers: profile.followers || 0,\n    bio: profile.bio || '',\n    source: profile.source || '',\n    source_type: profile.sourceType || '',\n    has_art_content: profile.has_art_content || false,\n    verified: profile.verified || false,\n    niche_relevance: analysis.niche_relevance || 5,\n    profile_score: analysis.profile_score || 5,\n    recommendation: analysis.recommendation || 'REVIEW',\n    reasoning: analysis.reasoning || '',\n    status: 'PENDING_REVIEW',\n    analyzed_at: new Date().toISOString(),\n    engagement_rate: profile.engagement_rate || 0,\n    avg_likes: profile.avg_likes || 0,\n    avg_comments: profile.avg_comments || 0,\n    avg_duration: profile.avg_duration || 0,\n    total_reels_found: profile.total_reels_found || 0,\n    prompt_version: PROMPT_VERSION_CLAUDE,\n\n    reel_1_url: profile.reel_1_url || '',\n    reel_1_post_url: profile.reel_1_post_url || '',\n    reel_1_likes: profile.reel_1_likes || 0,\n    reel_1_comments: profile.reel_1_comments || 0,\n    reel_1_duration: profile.reel_1_duration || 0,\n    reel_1_caption: profile.reel_1_caption || '',\n\n    reel_2_url: profile.reel_2_url || '',\n    reel_2_post_url: profile.reel_2_post_url || '',\n    reel_2_likes: profile.reel_2_likes || 0,\n    reel_2_comments: profile.reel_2_comments || 0,\n    reel_2_duration: profile.reel_2_duration || 0,\n    reel_2_caption: profile.reel_2_caption || '',\n\n    reel_3_url: profile.reel_3_url || '',\n    reel_3_post_url: profile.reel_3_post_url || '',\n    reel_3_likes: profile.reel_3_likes || 0,\n    reel_3_comments: profile.reel_3_comments || 0,\n    reel_3_duration: profile.reel_3_duration || 0,\n    reel_3_caption: profile.reel_3_caption || ''\n  }\n};\n"
        },
        "id": "f6b4ee91-463b-42ca-84b2-fb94f5754783",
        "name": "Merge",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -3424,
          288
        ],
        "notesInFlow": true,
        "notes": "\u2705 Enhanced: better error handling, all fields mapped"
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// Save to DB \u2014 Phase 1 Code Node\n// Inserts or upserts the Claude-analyzed profile into the profiles table.\n// Uses native https to avoid n8n Supabase node credential issues.\n//\n// n8n WIRING:\n// Merge (Claude Analysis) \u2192 this node \u2192 Download & Store Reels\n\nconst https = require('https');\nconst profile = $input.item.json;\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabasePost(path, body, extraHeaders) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: 'POST',\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal,resolution=merge-duplicates',\n        'Content-Length': Buffer.byteLength(data),\n        ...extraHeaders\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => {\n        if (res.statusCode >= 200 && res.statusCode < 300) {\n          resolve({ status: res.statusCode, data: responseData });\n        } else {\n          reject(new Error(`Supabase ${res.statusCode}: ${responseData}`));\n        }\n      });\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\n// Debug: log to debug_log table\nasync function debugLog(username, message, data) {\n  try {\n    await supabasePost('/rest/v1/debug_log', {\n      node_name: 'Save DB',\n      username: username || 'unknown',\n      message: message,\n      data: typeof data === 'string' ? data.substring(0, 500) : JSON.stringify(data).substring(0, 500)\n    }, { 'Prefer': 'return=minimal' });\n  } catch (e) {\n    // ignore debug log failures\n  }\n}\n\nawait debugLog(profile.username, 'ENTER Save DB', {\n  has_username: !!profile.username,\n  has_source: !!profile.source,\n  keys: Object.keys(profile).length\n});\n\nif (profile._skip) {\n  await debugLog(profile.username || 'unknown', 'SKIP - empty Claude response', profile);\n  return { json: profile };\n}\n\nif (!profile.username) {\n  await debugLog('null', 'SKIP - no username', profile);\n  return { json: profile };\n}\n\nconst row = {\n  username: profile.username,\n  followers: profile.followers || 0,\n  bio: profile.bio || '',\n  source: profile.source || '',\n  source_type: profile.source_type || '',\n  has_art_content: profile.has_art_content || false,\n  verified: profile.verified || false,\n  niche_relevance: profile.niche_relevance || 5,\n  profile_score: profile.profile_score || 5,\n  recommendation: profile.recommendation || 'REVIEW',\n  reasoning: profile.reasoning || '',\n  status: profile.status || 'PENDING_REVIEW',\n  analyzed_at: profile.analyzed_at || new Date().toISOString(),\n  engagement_rate: profile.engagement_rate || 0,\n  avg_likes: profile.avg_likes || 0,\n  avg_comments: profile.avg_comments || 0,\n  avg_duration: profile.avg_duration || 0,\n  total_reels_found: profile.total_reels_found || 0,\n  prompt_version: profile.prompt_version || 1,\n  reel_1_url: profile.reel_1_url || '',\n  reel_1_post_url: profile.reel_1_post_url || '',\n  reel_1_likes: profile.reel_1_likes || 0,\n  reel_1_comments: profile.reel_1_comments || 0,\n  reel_1_duration: profile.reel_1_duration || 0,\n  reel_1_caption: profile.reel_1_caption || '',\n  reel_2_url: profile.reel_2_url || '',\n  reel_2_post_url: profile.reel_2_post_url || '',\n  reel_2_likes: profile.reel_2_likes || 0,\n  reel_2_comments: profile.reel_2_comments || 0,\n  reel_2_duration: profile.reel_2_duration || 0,\n  reel_2_caption: profile.reel_2_caption || '',\n  reel_3_url: profile.reel_3_url || '',\n  reel_3_post_url: profile.reel_3_post_url || '',\n  reel_3_likes: profile.reel_3_likes || 0,\n  reel_3_comments: profile.reel_3_comments || 0,\n  reel_3_duration: profile.reel_3_duration || 0,\n  reel_3_caption: profile.reel_3_caption || ''\n};\n\ntry {\n  await supabasePost('/rest/v1/profiles?on_conflict=username', row);\n  await debugLog(profile.username, 'SUCCESS', { status: 'upserted' });\n} catch (e) {\n  await debugLog(profile.username, 'ERROR: ' + e.message, { row_keys: Object.keys(row) });\n}\n\nreturn { json: profile };\n"
        },
        "id": "7088a7fd-a93d-4035-b59e-ca94dc87986a",
        "name": "Save DB",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -3008,
          288
        ],
        "notesInFlow": true,
        "onError": "continueRegularOutput",
        "notes": "\u2705 Code node: native HTTPS insert to profiles"
      },
      {
        "parameters": {},
        "id": "6b5167f8-6b38-4133-ac52-995506b31206",
        "name": "Done",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          -2464,
          288
        ],
        "notesInFlow": true,
        "notes": "\u2705 Phase 1 Complete!"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.apify.com/v2/acts/apify~instagram-scraper/run-sync-get-dataset-items",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "apifyApi",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"directUrls\": [\"https://www.instagram.com/{{ $json.competitor }}/tagged/\"],\n  \"resultsLimit\": {{ $json.resultsLimit }},\n  \"resultsType\": \"posts\"\n}",
          "options": {
            "timeout": 300000
          }
        },
        "id": "21c6879a-68d1-4c2c-ac85-6bbe065a661d",
        "name": "Apify: Tagged Posts",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -6336,
          304
        ],
        "credentials": {
          "apifyApi": {
            "id": "UXM2kDAyAdkPfO2Q",
            "name": "Apify account"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// ====== SETTINGS ======\nconst COMPETITORS = [\n  \"aaronblaiseart\",\n  \"rchrd.powell\"\n];\nconst RESULTS_LIMIT = 200;\nconst SIMILAR_LIMIT = 100;\nconst MIN_FOLLOWERS = 2000;\nconst MAX_FOLLOWERS = 200000;\n// ======================\n\nreturn COMPETITORS.map(competitor => ({\n  json: {\n    competitor: competitor,\n    resultsLimit: RESULTS_LIMIT,\n    similarLimit: SIMILAR_LIMIT,\n    minFollowers: MIN_FOLLOWERS,\n    maxFollowers: MAX_FOLLOWERS,\n    excludeUsernames: COMPETITORS\n  }\n}));"
        },
        "id": "96fb2442-4b09-4386-80d3-0f77a1f8ea9c",
        "name": "Settings1",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -6560,
          304
        ],
        "notesInFlow": true,
        "notes": "Edit settings here"
      },
      {
        "parameters": {
          "jsCode": "const posts = $input.all().map(i => i.json);\nconst settings = $('Settings1').first().json;\nconst unique = new Map();\n\nconst excludeUsernames = settings.excludeUsernames || [settings.competitor];\n\nfor (const p of posts) {\n  // 1. Owner (for education accounts like domestika - students tag them)\n  const owner = p.ownerUsername;\n  if (owner && !unique.has(owner) && !excludeUsernames.includes(owner)) {\n    unique.set(owner, {\n      username: owner,\n      source: settings.competitor,\n      sourceType: 'tagged'\n    });\n  }\n  \n  // 2. Mentions (for curation accounts like drawing.collection - they feature artists)\n  const mentions = p.mentions || [];\n  for (const m of mentions) {\n    if (m && !unique.has(m) && !excludeUsernames.includes(m)) {\n      unique.set(m, {\n        username: m,\n        source: settings.competitor,\n        sourceType: 'mentioned'\n      });\n    }\n  }\n}\n\nreturn Array.from(unique.values()).map(p => ({ json: p }));"
        },
        "id": "88033fab-eafe-4ad8-8272-8a4c07a5cd3e",
        "name": "Extract Profiles1",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -6112,
          304
        ]
      },
      {
        "parameters": {
          "operation": "Run actor and get dataset",
          "actorId": {
            "__rl": true,
            "value": "dSCLg0C3YEZ83HzYX",
            "mode": "list",
            "cachedResultName": "Instagram Profile Scraper (apify/instagram-profile-scraper)",
            "cachedResultUrl": "https://console.apify.com/actors/dSCLg0C3YEZ83HzYX/input"
          },
          "customBody": "={\n  \"usernames\": [\"{{ $json.username }}\"],\n  \"resultsLimit\": 50\n}"
        },
        "type": "@apify/n8n-nodes-apify.apify",
        "typeVersion": 1,
        "position": [
          -4704,
          304
        ],
        "id": "7b6f3298-8a48-42b0-99d6-466afb8cc940",
        "name": "Run an Actor and get dataset",
        "credentials": {
          "apifyApi": {
            "id": "UXM2kDAyAdkPfO2Q",
            "name": "Apify account"
          }
        }
      },
      {
        "parameters": {
          "content": "\ud83d\udce5 STAGE 1: DATA FETCH\nScrapes competitor tagged posts\nExtracts unique usernames",
          "height": 784,
          "width": 1600
        },
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          -6832,
          -64
        ],
        "id": "744c6aa5-2951-4ba6-b43b-2aa9994fa14b",
        "name": "Sticky Note"
      },
      {
        "parameters": {
          "content": "\ud83d\udcca STAGE 2: ENRICHMENT\nFull profile scrape via Apify\nGets followers, bio, reels, etc.",
          "height": 784,
          "width": 656,
          "color": 3
        },
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          -5168,
          -64
        ],
        "id": "0b08a3b0-a301-446c-ad41-d223b9913252",
        "name": "Sticky Note1"
      },
      {
        "parameters": {
          "content": "\ud83e\udd16 STAGE 3: AI ANALYSIS\nChecks if profile exists\nFilters qualifying reels\nClaude scores & recommends",
          "height": 784,
          "width": 1296,
          "color": 4
        },
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          -4464,
          -64
        ],
        "id": "1b461eb0-72c9-45ea-938f-f7d7c68b32dd",
        "name": "Sticky Note2"
      },
      {
        "parameters": {
          "content": "\ud83d\udcbe STAGE 4: SAVE\nSaves to Supabase profiles table\nStatus: PENDING_REVIEW",
          "height": 768,
          "width": 864,
          "color": 6
        },
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          -3088,
          -48
        ],
        "id": "e2b68fe8-e1dc-4f37-a7bd-fefacf05cf9f",
        "name": "Sticky Note3"
      },
      {
        "parameters": {
          "operation": "getAll",
          "tableId": "profiles",
          "limit": 20,
          "matchType": "allFilters",
          "filters": {
            "conditions": [
              {
                "keyName": "status",
                "condition": "neq",
                "keyValue": "VIDEO_ANALYZED"
              },
              {
                "keyName": "recommendation",
                "condition": "eq",
                "keyValue": "COLLABORATE"
              },
              {
                "keyName": "status",
                "condition": "neq",
                "keyValue": "DOWNLOAD_FAILED"
              }
            ]
          }
        },
        "name": "Get COLLABORATE Profiles",
        "type": "n8n-nodes-base.supabase",
        "typeVersion": 1,
        "position": [
          -6576,
          1584
        ],
        "id": "036d8559-5854-4f65-8cad-af4610dbd662",
        "credentials": {
          "supabaseApi": {
            "id": "AK4efiLBvVR50hXA",
            "name": "Supabase account"
          }
        }
      },
      {
        "parameters": {
          "options": {}
        },
        "name": "Loop Profiles",
        "type": "n8n-nodes-base.splitInBatches",
        "typeVersion": 3,
        "position": [
          -6288,
          1584
        ],
        "id": "bb630022-6c4b-4879-81be-7469a8dcfeae"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyAA63nf0G3Wc4HMhFUL8EWGHX0RqBQyyCs",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ $json.requestBody }}",
          "options": {}
        },
        "name": "Gemini Video Analysis",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.1,
        "position": [
          -4176,
          1616
        ],
        "id": "efd430d8-2e24-4185-9bf7-733324a03b2a"
      },
      {
        "parameters": {
          "tableId": "ai_logs",
          "fieldsUi": {
            "fieldValues": [
              {
                "fieldId": "profile_username",
                "fieldValue": "={{ $('Loop Profiles').item.json.username }}"
              },
              {
                "fieldId": "workflow_name",
                "fieldValue": "WF-Video-Analysis"
              },
              {
                "fieldId": "model_used",
                "fieldValue": "gemini-1.5-flash"
              },
              {
                "fieldId": "input_data",
                "fieldValue": "={{ JSON.stringify({ reel_url: $('Loop Profiles').item.json.reel_1_url, username: $('Loop Profiles').item.json.username }) }}"
              },
              {
                "fieldId": "output_raw",
                "fieldValue": "={{ JSON.stringify($json) }}"
              },
              {
                "fieldId": "prompt_version",
                "fieldValue": "1"
              }
            ]
          }
        },
        "name": "Log to AI Logs",
        "type": "n8n-nodes-base.supabase",
        "typeVersion": 1,
        "position": [
          -3760,
          1616
        ],
        "id": "440a7e98-9b27-4f51-b3e9-3ba591c37521",
        "credentials": {
          "supabaseApi": {
            "id": "AK4efiLBvVR50hXA",
            "name": "Supabase account"
          }
        }
      },
      {
        "parameters": {
          "operation": "update",
          "tableId": "profiles",
          "filters": {
            "conditions": [
              {
                "keyName": "username",
                "condition": "eq",
                "keyValue": "={{ $('Loop Profiles').item.json.username }}"
              }
            ]
          },
          "fieldsUi": {
            "fieldValues": [
              {
                "fieldId": "username",
                "fieldValue": "={{ $('Loop Profiles').item.json.username }}"
              },
              {
                "fieldId": "status",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.status_override }}"
              },
              {
                "fieldId": "talks_in_videos",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.talks_in_videos }}"
              },
              {
                "fieldId": "speaks_english",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.speaks_english }}"
              },
              {
                "fieldId": "overall_ugc_score",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.overall_ugc_score }}"
              },
              {
                "fieldId": "content_style",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.video_summary }}"
              },
              {
                "fieldId": "voice_potential",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.voice_potential }}"
              },
              {
                "fieldId": "teaching_potential",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.teaching_potential }}"
              },
              {
                "fieldId": "production_quality",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.content_quality }}"
              },
              {
                "fieldId": "brand_fit",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.brand_fit }}"
              },
              {
                "fieldId": "ugc_reasoning",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.ugc_reasoning }}"
              },
              {
                "fieldId": "video_recommendation",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.recommendation }}"
              },
              {
                "fieldId": "next_steps",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.next_steps }}"
              },
              {
                "fieldId": "audio_description",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.audio_description }}"
              },
              {
                "fieldId": "speech_quote",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.speech_quote }}"
              },
              {
                "fieldId": "videos_with_speech",
                "fieldValue": "={{ $('Parse Gemini Response').item.json.videos_with_speech }}"
              }
            ]
          }
        },
        "name": "Update Profile Status",
        "type": "n8n-nodes-base.supabase",
        "typeVersion": 1,
        "position": [
          -3728,
          1904
        ],
        "id": "d9e5bff5-579c-468b-ba62-fd0cff788c33",
        "credentials": {
          "supabaseApi": {
            "id": "AK4efiLBvVR50hXA",
            "name": "Supabase account"
          }
        }
      },
      {
        "parameters": {},
        "name": "Phase 2 Done",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          -5936,
          1472
        ],
        "id": "e841dc67-febb-4e56-8020-4d958259ff06"
      },
      {
        "parameters": {
          "jsCode": "const item = $('Loop Profiles').item.json;\n\n// Get file URIs from all 3 uploads\nconst fileUri1 = $('Upload Reel 1').item.json?.file?.uri || '';\nconst fileUri2 = $('Upload Reel 2').item.json?.file?.uri || '';\nconst fileUri3 = $('Upload Reel 3').item.json?.file?.uri || '';\n\n// Build parts array with only videos that exist\nconst parts = [];\n\nif (fileUri1) {\n  parts.push({\n    fileData: {\n      mimeType: \"video/mp4\",\n      fileUri: fileUri1\n    }\n  });\n}\n\nif (fileUri2) {\n  parts.push({\n    fileData: {\n      mimeType: \"video/mp4\",\n      fileUri: fileUri2\n    }\n  });\n}\n\nif (fileUri3) {\n  parts.push({\n    fileData: {\n      mimeType: \"video/mp4\",\n      fileUri: fileUri3\n    }\n  });\n}\n\n// Count how many videos we have\nconst videoCount = parts.length;\n\n// \u2500\u2500 SKIP if no videos uploaded (downloads timed out or failed) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nif (videoCount === 0) {\n  return {\n    json: {\n      skip_gemini: true,\n      skip_reason: 'No videos uploaded \u2014 downloads may have timed out',\n      username: item.username\n    }\n  };\n}\n\n// Add the prompt\nparts.push({\n  text: `You are evaluating Instagram creators for UGC partnerships with 21Draw, an online art education platform.\n\nCREATOR INFO:\n- Username: ${item.username}\n- Followers: ${item.followers}\n- Bio: ${item.bio}\n\nREEL 1 CAPTION: ${item.reel_1_caption || 'N/A'}\nREEL 2 CAPTION: ${item.reel_2_caption || 'N/A'}\nREEL 3 CAPTION: ${item.reel_3_caption || 'N/A'}\n\nI have provided ${videoCount} video(s) for you to analyze.\n\nWATCH AND LISTEN TO ALL VIDEOS CAREFULLY. Evaluate the creator based on ALL videos:\n\n1. **talks_in_videos** (true/false): Does the creator SPEAK with their voice in ANY of the videos?\n   - TRUE = creator talks, explains, or narrates with spoken words in at least one video\n   - FALSE = no speech in any video, only music, sound effects, or silence\n   - Background music does NOT count as talking\n   - Text overlays do NOT count as talking\n   - Songs with lyrics do NOT count as the creator talking\n\n2. **audio_description**: What sounds do you HEAR in each video? Be specific. Format:\n   - Reel 1: [describe audio]\n   - Reel 2: [describe audio] (if provided)\n   - Reel 3: [describe audio] (if provided)\n\n3. **speech_quote**: If the creator speaks in ANY video, provide ONE short quote (5-10 words) of what they actually said. If no speech in any video, write \"N/A\".\n\n4. **speaks_english** (true/false): If they speak, is it in English? (false if no speech)\n\n5. **videos_with_speech**: How many of the videos have the creator speaking? (0, 1, 2, or 3)\n\n6. **voice_potential** (0-10): Based on their content style, how likely could they do voiceover work?\n7. **teaching_potential** (0-10): Could they teach art concepts?\n8. **content_quality** (0-10): Production quality and visual appeal\n9. **brand_fit** (0-10): Fit with art education brand\n10. **overall_ugc_score** (0-10): Overall UGC partnership potential\n\n11. **video_summary**: Briefly describe what happens across all videos\n12. **ugc_reasoning**: Why would they be a good/bad UGC partner?\n13. **recommendation**: STRONG_YES / YES / MAYBE / NO\n14. **next_steps**: What to verify before outreach?\n\nIMPORTANT: Be accurate about audio. Do not assume speech exists just because it's a tutorial. Many art videos have only music.\n\nRespond with JSON only, no markdown:\n{\"talks_in_videos\": false, \"audio_description\": \"\", \"speech_quote\": \"N/A\", \"speaks_english\": false, \"videos_with_speech\": 0, \"voice_potential\": 0, \"teaching_potential\": 0, \"content_quality\": 0, \"brand_fit\": 0, \"overall_ugc_score\": 0, \"video_summary\": \"\", \"ugc_reasoning\": \"\", \"recommendation\": \"\", \"next_steps\": \"\"}`\n});\n\nreturn {\n  json: {\n    skip_gemini: false,\n    requestBody: {\n      contents: [{\n        parts: parts\n      }]\n    },\n    username: item.username\n  }\n};\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -4608,
          1600
        ],
        "id": "1353cbf4-02f3-4520-97e3-5208c9a81820",
        "name": "Code in JavaScript"
      },
      {
        "parameters": {
          "rule": {
            "interval": [
              {
                "field": "hours",
                "hoursInterval": 23
              }
            ]
          }
        },
        "type": "n8n-nodes-base.scheduleTrigger",
        "typeVersion": 1.3,
        "position": [
          -6832,
          1584
        ],
        "id": "cca15f70-e50e-4801-9505-ff2eebcdfacc",
        "name": "Schedule Trigger"
      },
      {
        "parameters": {
          "jsCode": "// Parse Gemini Response \u2014 Phase 2 Code Node\n// Extracts JSON scores from Gemini response\n// Includes validation to catch:\n//   1. \"No video provided\" responses (Gemini analyzed captions only)\n//   2. Hallucinations (talks_in_videos=true but audio contradicts)\n//\n// n8n WIRING:\n// Gemini Video Analysis \u2192 this node \u2192 Log to AI Logs + Update Profile Status\n\nconst geminiResponse = $input.item.json;\nconst loopData = $('Loop Profiles').item.json;\n\n// Extract the text from Gemini response\nlet text = geminiResponse.candidates[0].content.parts[0].text;\n\n// Remove markdown code blocks if present\ntext = text.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n\n// Parse the JSON\nlet parsed;\ntry {\n  parsed = JSON.parse(text);\n} catch (e) {\n  parsed = {\n    talks_in_videos: false,\n    speaks_english: false,\n    voice_potential: 0,\n    teaching_potential: 0,\n    content_quality: 0,\n    brand_fit: 0,\n    overall_ugc_score: 0,\n    video_summary: \"Failed to parse response\",\n    ugc_reasoning: \"Parse error\",\n    recommendation: \"MAYBE\",\n    next_steps: \"Manual review needed\",\n    audio_description: \"\",\n    speech_quote: \"N/A\",\n    videos_with_speech: 0\n  };\n}\n\n// \u2500\u2500 VALIDATION 1: Detect \"no video provided\" responses \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// If Gemini didn't receive the actual video, it analyzes based on captions only.\n// These responses contain telltale phrases in audio_description.\nconst audioDesc = (parsed.audio_description || '').toLowerCase();\nconst noVideoPatterns = [\n  'no video provided',\n  'no audio provided',\n  'no audio information',\n  'based on the caption',\n  'no video available',\n  'without video',\n  'cannot analyze'\n];\nconst noVideoReceived = noVideoPatterns.some(pattern => audioDesc.includes(pattern));\n\nlet statusOverride = 'VIDEO_ANALYZED';\nlet validationNote = '';\n\nif (noVideoReceived) {\n  // Gemini didn't receive the video \u2014 zero out scores, mark as failed\n  statusOverride = 'ANALYSIS_FAILED';\n  validationNote = '[NO VIDEO RECEIVED] ';\n  parsed.talks_in_videos = false;\n  parsed.speaks_english = false;\n  parsed.voice_potential = 0;\n  parsed.teaching_potential = 0;\n  parsed.content_quality = 0;\n  parsed.brand_fit = 0;\n  parsed.overall_ugc_score = 0;\n  parsed.videos_with_speech = 0;\n  parsed.speech_quote = 'N/A';\n  parsed.recommendation = 'NO';\n  parsed.ugc_reasoning = 'Analysis invalid \u2014 Gemini did not receive video files. Needs re-analysis.';\n}\n\n// \u2500\u2500 VALIDATION 2: Detect hallucinations \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// If talks_in_videos=true but audio_description has no speech-related words,\n// the model is likely hallucinating speech.\nif (!noVideoReceived && parsed.talks_in_videos === true) {\n  const speechKeywords = ['speech', 'speak', 'talk', 'narrat', 'voice', 'explain', 'says', 'said', 'comment', 'discuss', 'instruct', 'teach', 'verbal', 'word'];\n  const hasSpeeechEvidence = speechKeywords.some(kw => audioDesc.includes(kw));\n\n  if (!hasSpeeechEvidence) {\n    // Audio description contradicts talks_in_videos \u2014 correct it\n    validationNote = '[CORRECTED: talks_in_videos overridden to false \u2014 audio_description has no speech evidence] ';\n    parsed.talks_in_videos = false;\n    parsed.speaks_english = false;\n    parsed.videos_with_speech = 0;\n    parsed.speech_quote = 'N/A';\n  }\n}\n\nreturn {\n  json: {\n    // Original profile data\n    username: loopData.username,\n    reel_url: loopData.reel_1_url,\n\n    // Status (VIDEO_ANALYZED or ANALYSIS_FAILED)\n    status_override: statusOverride,\n\n    // Parsed video scores (may be zeroed/corrected by validation)\n    talks_in_videos: parsed.talks_in_videos || false,\n    speaks_english: parsed.speaks_english || false,\n    voice_potential: parsed.voice_potential || 0,\n    teaching_potential: parsed.teaching_potential || 0,\n    content_quality: parsed.content_quality || 0,\n    brand_fit: parsed.brand_fit || 0,\n    overall_ugc_score: parsed.overall_ugc_score || 0,\n\n    // Hallucination detection fields\n    audio_description: validationNote + (parsed.audio_description || \"\"),\n    speech_quote: parsed.speech_quote || \"N/A\",\n    videos_with_speech: parsed.videos_with_speech || 0,\n\n    // Text fields\n    video_summary: parsed.video_summary || \"\",\n    ugc_reasoning: parsed.ugc_reasoning || \"\",\n    recommendation: parsed.recommendation || \"MAYBE\",\n    next_steps: parsed.next_steps || \"\",\n\n    // Keep raw response for logging\n    raw_response: geminiResponse\n  }\n};\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -3984,
          1616
        ],
        "id": "c51ca7c0-12f0-475e-91ce-6ab57cd09cde",
        "name": "Parse Gemini Response"
      },
      {
        "parameters": {
          "amount": 90
        },
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          -4800,
          1600
        ],
        "id": "c3da5d1e-b6e3-4a03-abcc-83a4b82bba32",
        "name": "Wait",
        "webhookId": "0f6a3d96-133e-449c-b87a-f1d9e773e4a6"
      },
      {
        "parameters": {
          "url": "={{ $('Build Storage URLs').item.json.reel_1_download_url }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_ROLE_KEY }}"
              }
            ]
          },
          "options": {
            "response": {
              "response": {
                "responseFormat": "file"
              }
            },
            "timeout": 120000
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          -5840,
          1776
        ],
        "id": "9056baf0-459f-4cd3-8e06-da46a6149921",
        "name": "Download Reel 1",
        "alwaysOutputData": false,
        "executeOnce": false,
        "retryOnFail": false,
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://generativelanguage.googleapis.com/upload/v1beta/files?key=AIzaSyAA63nf0G3Wc4HMhFUL8EWGHX0RqBQyyCs",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "X-Goog-Upload-Command",
                "value": "start, upload, finalize"
              },
              {
                "name": "X-Goog-Upload-Header-Content-Length",
                "value": "={{ $binary.data.fileSize }}"
              },
              {
                "name": "X-Goog-Upload-Header-Content-Type",
                "value": "video/mp4"
              },
              {
                "name": "Content-Type",
                "value": "video/mp4"
              }
            ]
          },
          "sendBody": true,
          "contentType": "binaryData",
          "inputDataFieldName": "data",
          "options": {
            "timeout": 120000
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          -5680,
          1776
        ],
        "id": "f0b79cb8-387d-4a38-be8d-56202bb7e8d0",
        "name": "Upload Reel 1",
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "url": "={{ $('Build Storage URLs').item.json.reel_3_download_url }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_ROLE_KEY }}"
              }
            ]
          },
          "options": {
            "response": {
              "response": {
                "responseFormat": "file"
              }
            },
            "timeout": 120000
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          -5184,
          1776
        ],
        "id": "8ba7d35a-60f6-4e8f-ae40-0869489df924",
        "name": "Download Reel 3",
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://generativelanguage.googleapis.com/upload/v1beta/files?key=AIzaSyAA63nf0G3Wc4HMhFUL8EWGHX0RqBQyyCs",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "X-Goog-Upload-Command",
                "value": "start, upload, finalize"
              },
              {
                "name": "X-Goog-Upload-Header-Content-Length",
                "value": "={{ $binary.data.fileSize }}"
              },
              {
                "name": "X-Goog-Upload-Header-Content-Type",
                "value": "video/mp4"
              },
              {
                "name": "Content-Type",
                "value": "video/mp4"
              }
            ]
          },
          "sendBody": true,
          "contentType": "binaryData",
          "inputDataFieldName": "data",
          "options": {
            "timeout": 120000
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          -5008,
          1776
        ],
        "id": "a058417e-4c24-4f8c-9822-6652de484160",
        "name": "Upload Reel 3",
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "url": "={{ $('Build Storage URLs').item.json.reel_2_download_url }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_ROLE_KEY }}"
              }
            ]
          },
          "options": {
            "response": {
              "response": {
                "responseFormat": "file"
              }
            },
            "timeout": 120000
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          -5520,
          1776
        ],
        "id": "a9ef592a-b649-4ad2-b8a0-bf01e973319a",
        "name": "Download Reel 2",
        "retryOnFail": false,
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://generativelanguage.googleapis.com/upload/v1beta/files?key=AIzaSyAA63nf0G3Wc4HMhFUL8EWGHX0RqBQyyCs",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "X-Goog-Upload-Command",
                "value": "start, upload, finalize"
              },
              {
                "name": "X-Goog-Upload-Header-Content-Length",
                "value": "={{ $binary.data.fileSize }}"
              },
              {
                "name": "X-Goog-Upload-Header-Content-Type",
                "value": "video/mp4"
              },
              {
                "name": "Content-Type",
                "value": "video/mp4"
              }
            ]
          },
          "sendBody": true,
          "contentType": "binaryData",
          "inputDataFieldName": "data",
          "options": {
            "timeout": 120000
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          -5360,
          1776
        ],
        "id": "c72c7330-3f33-409d-9832-9cb5a71ee53a",
        "name": "Upload Reel 2",
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Get all profiles from Apify\nconst profiles = $input.all();\n\n// Extract all usernames\nconst usernames = profiles.map(p => p.json.username).filter(Boolean);\n\nif (usernames.length === 0) {\n  return [];\n}\n\n// Query Supabase for existing usernames using n8n's helper\nconst supabaseUrl = 'https://gwytongsbnciyulphcjv.supabase.co'; // Replace with YOUR Supabase URL\nconst supabaseKey = 'sb_publishable_sd_h9oeThdDwpxUkupUYzQ_ScmwMZ6L'; // Replace with YOUR Supabase anon key\n\nconst usernameList = usernames.map(u => `\"${u}\"`).join(',');\n\nconst response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/profiles?username=in.(${usernameList})&select=username`,\n  headers: {\n    'apikey': supabaseKey,\n    'Authorization': `Bearer ${supabaseKey}`\n  }\n});\n\nconst existingUsernames = new Set(response.map(p => p.username));\n\n// Filter to only new profiles\nconst newProfiles = profiles.filter(p => !existingUsernames.has(p.json.username));\n\nconsole.log(`Found ${existingUsernames.size} existing profiles, ${newProfiles.length} new profiles`);\n\nreturn newProfiles;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -4144,
          848
        ],
        "id": "1c89c04b-a239-4b56-a0d0-1b5b1d89f57b",
        "name": "Filter New Profiles",
        "alwaysOutputData": true,
        "disabled": true
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose",
              "version": 3
            },
            "conditions": [
              {
                "id": "0ef1439e-a71c-4de3-a4f6-35a72d338b56",
                "leftValue": "={{ $json._skip }}",
                "rightValue": "true",
                "operator": {
                  "type": "string",
                  "operation": "notEquals"
                }
              }
            ],
            "combinator": "and"
          },
          "looseTypeValidation": true,
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          -4080,
          304
        ],
        "id": "e38f01f7-4217-41fe-84fb-bd5a79008120",
        "name": "If"
      },
      {
        "parameters": {
          "amount": 2
        },
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          -4912,
          304
        ],
        "id": "8318ed40-450b-4828-941b-8f586a0f7b3a",
        "name": "Wait1",
        "webhookId": "265960d0-02dc-4cc0-b9df-554b0a230c93"
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// Download & Store Reels to Supabase Storage\n// Run AFTER \"Save to DB\" node in Phase 1 while CDN URLs are still fresh\n//\n// n8n WIRING:\n// Save DB \u2192 this node \u2192 Done\n//\n// This node downloads each reel from Instagram CDN and uploads to Supabase Storage,\n// then updates the profile row with the storage paths.\n\nconst https = require('https');\nconst http = require('http');\nconst profile = $input.item.json;\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\nconst BUCKET = 'reel-videos';\n\nconst results = {\n  username: profile.username,\n  reel_1_storage_path: null,\n  reel_2_storage_path: null,\n  reel_3_storage_path: null,\n  videos_downloaded: false,\n  downloaded_count: 0,\n  errors: []\n};\n\nfunction downloadUrl(url) {\n  return new Promise((resolve, reject) => {\n    const client = url.startsWith('https') ? https : http;\n    client.get(url, { headers: { 'User-Agent': 'Mozilla/5.0' } }, (res) => {\n      // Handle redirects\n      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n        return downloadUrl(res.headers.location).then(resolve).catch(reject);\n      }\n      if (res.statusCode !== 200) {\n        return reject(new Error(`Download failed: ${res.statusCode}`));\n      }\n      const chunks = [];\n      res.on('data', (chunk) => chunks.push(chunk));\n      res.on('end', () => resolve(Buffer.concat(chunks)));\n      res.on('error', reject);\n    }).on('error', reject);\n  });\n}\n\nfunction uploadToStorage(storagePath, videoBuffer) {\n  return new Promise((resolve, reject) => {\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: `/storage/v1/object/${BUCKET}/${storagePath}`,\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'video/mp4',\n        'x-upsert': 'true',\n        'Content-Length': videoBuffer.length\n      }\n    };\n    const req = https.request(options, (res) => {\n      let data = '';\n      res.on('data', (chunk) => data += chunk);\n      res.on('end', () => {\n        if (res.statusCode >= 200 && res.statusCode < 300) {\n          resolve(data);\n        } else {\n          reject(new Error(`Upload failed: ${res.statusCode} ${data}`));\n        }\n      });\n    });\n    req.on('error', reject);\n    req.write(videoBuffer);\n    req.end();\n  });\n}\n\nfunction supabasePatch(path, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: 'PATCH',\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal',\n        'Content-Length': Buffer.byteLength(data)\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data: responseData }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\nasync function downloadAndStore(reelUrl, reelNumber) {\n  if (!reelUrl) return null;\n\n  try {\n    const videoBuffer = await downloadUrl(reelUrl);\n    const storagePath = `${profile.username}/reel_${reelNumber}.mp4`;\n    await uploadToStorage(storagePath, videoBuffer);\n    return storagePath;\n  } catch (err) {\n    results.errors.push(`Reel ${reelNumber}: ${err.message}`);\n    return null;\n  }\n}\n\n// Download all 3 reels (sequential to avoid overwhelming Instagram)\nconst path1 = await downloadAndStore(profile.reel_1_url, 1);\nconst path2 = await downloadAndStore(profile.reel_2_url, 2);\nconst path3 = await downloadAndStore(profile.reel_3_url, 3);\n\nresults.reel_1_storage_path = path1;\nresults.reel_2_storage_path = path2;\nresults.reel_3_storage_path = path3;\nresults.downloaded_count = [path1, path2, path3].filter(Boolean).length;\nresults.videos_downloaded = results.downloaded_count > 0;\n\n// Update profile in Supabase with storage paths\nif (results.videos_downloaded) {\n  try {\n    await supabasePatch(\n      `/rest/v1/profiles?username=eq.${encodeURIComponent(profile.username)}`,\n      {\n        reel_1_storage_path: path1,\n        reel_2_storage_path: path2,\n        reel_3_storage_path: path3,\n        videos_downloaded: true\n      }\n    );\n  } catch (e) {\n    console.log('Failed to update storage paths:', e.message);\n  }\n}\n\nreturn {\n  json: {\n    ...profile,\n    ...results\n  }\n};\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -2736,
          288
        ],
        "id": "634502ef-7751-4ad5-842c-73cd84b19c66",
        "name": "Download & Store Reels"
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "const profile = $input.item.json;\nconst SUPABASE_URL = 'https://gwytongsbnciyulphcjv.supabase.co';\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction buildDownloadUrl(storagePath, cdnFallback) {\n  if (storagePath) {\n    return `${SUPABASE_URL}/storage/v1/object/authenticated/reel-videos/${storagePath}`;\n  }\n  return cdnFallback || '';\n}\n\nreturn {\n  json: {\n    ...profile,\n    reel_1_download_url: buildDownloadUrl(profile.reel_1_storage_path, profile.reel_1_url),\n    reel_2_download_url: buildDownloadUrl(profile.reel_2_storage_path, profile.reel_2_url),\n    reel_3_download_url: buildDownloadUrl(profile.reel_3_storage_path, profile.reel_3_url),\n    using_storage: !!(profile.reel_1_storage_path || profile.reel_2_storage_path || profile.reel_3_storage_path)\n  }\n};"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -6048,
          1600
        ],
        "id": "9401c890-9e03-4b58-afae-9911c6c25844",
        "name": "Build Storage URLs"
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "skip-check",
                "leftValue": "={{ $json.skip_gemini }}",
                "rightValue": "",
                "operator": {
                  "type": "boolean",
                  "operation": "true"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          -4400,
          1600
        ],
        "id": "62a7446d-3c09-4f78-823b-b0c9ac8eb63a",
        "name": "Skip Check"
      },
      {
        "parameters": {
          "jsCode": "// Handle Skipped Profile \u2014 Phase 2 Code Node\n// Runs when Build Gemini Request returns skip_gemini=true (0 videos uploaded).\n// Logs the skip to ai_logs and skipped_profiles, marks profile as DOWNLOAD_FAILED.\n//\n// n8n WIRING:\n// Skip Check IF node [TRUE branch] \u2192 this node \u2192 Loop Profiles\n\nconst https = require('https');\nconst item = $input.item.json;\nconst SUPABASE_URL = 'https://gwytongsbnciyulphcjv.supabase.co';\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabaseRequest(method, path, body) {\n  return new Promise((resolve, reject) => {\n    const data = body ? JSON.stringify(body) : '';\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: method,\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal',\n        'Content-Length': Buffer.byteLength(data)\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data: responseData }));\n    });\n    req.on('error', reject);\n    if (data) req.write(data);\n    req.end();\n  });\n}\n\n// Log to ai_logs\ntry {\n  await supabaseRequest('POST', '/rest/v1/ai_logs', {\n    profile_username: item.username,\n    workflow_name: 'WF-Video-Analysis',\n    model_used: 'SKIPPED',\n    output_raw: item.skip_reason || 'No videos uploaded',\n    audit_status: 'skipped_no_videos',\n    prompt_version: 1\n  });\n} catch (e) {\n  console.log('Failed to log to ai_logs:', e.message);\n}\n\n// Log to skipped_profiles for audit\ntry {\n  await supabaseRequest('POST', '/rest/v1/skipped_profiles', {\n    username: item.username,\n    skip_reason: item.skip_reason || 'NO_VIDEOS_UPLOADED',\n    workflow_stage: 'Phase2-VideoAnalysis',\n    source: item.source || 'unknown'\n  });\n} catch (e) {\n  console.log('Failed to log skip:', e.message);\n}\n\n// Mark profile so it doesn't get re-queued\ntry {\n  await supabaseRequest('PATCH', `/rest/v1/profiles?username=eq.${encodeURIComponent(item.username)}`, {\n    status: 'DOWNLOAD_FAILED'\n  });\n} catch (e) {\n  console.log('Failed to update profile status:', e.message);\n}\n\nreturn {\n  json: {\n    username: item.username,\n    action: 'skipped',\n    reason: item.skip_reason\n  }\n};\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -4304,
          1344
        ],
        "id": "47e7ed23-0d9f-469f-a45e-f6502ff0b09b",
        "name": "Handle Skipped Profile"
      },
      {
        "parameters": {
          "jsCode": "// Pre-Filter Known Profiles \u2014 Phase 1 Code Node\n// Removes usernames already in `profiles` or `seen_profiles` BEFORE sending to Apify.\n// Saves Apify credits by not re-scraping known profiles.\n// Also logs skipped profiles to `skipped_profiles` table for audit.\n//\n// n8n WIRING:\n// Dedupe Profiles \u2192 this node \u2192 Wait1 \u2192 Run an Actor (Apify)\n\nconst https = require('https');\nconst items = $input.all();\nconst usernames = items.map(i => i.json.username).filter(Boolean);\n\nif (usernames.length === 0) return [];\n\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabaseRequest(method, path, body) {\n  return new Promise((resolve, reject) => {\n    const data = body ? JSON.stringify(body) : '';\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: method,\n      headers: {\n        'apikey': SUPABASE_KEY,\n        'Authorization': `Bearer ${SUPABASE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'return=minimal',\n        'Content-Length': Buffer.byteLength(data)\n      }\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => {\n        try {\n          resolve({ status: res.statusCode, data: JSON.parse(responseData) });\n        } catch (e) {\n          resolve({ status: res.statusCode, data: responseData });\n        }\n      });\n    });\n    req.on('error', reject);\n    if (data) req.write(data);\n    req.end();\n  });\n}\n\n// Build comma-separated list for Supabase IN filter\nconst usernameList = usernames.map(u => encodeURIComponent(u)).join(',');\n\n// Check profiles table\nlet existingUsernames = new Set();\ntry {\n  const res = await supabaseRequest('GET', `/rest/v1/profiles?username=in.(${usernameList})&select=username`);\n  if (Array.isArray(res.data)) {\n    res.data.forEach(p => existingUsernames.add(p.username));\n  }\n} catch (e) {\n  console.log('Failed to query profiles:', e.message);\n}\n\n// Check seen_profiles table\ntry {\n  const res = await supabaseRequest('GET', `/rest/v1/seen_profiles?username=in.(${usernameList})&select=username`);\n  if (Array.isArray(res.data)) {\n    res.data.forEach(p => existingUsernames.add(p.username));\n  }\n} catch (e) {\n  // seen_profiles may not exist yet \u2014 continue\n  console.log('seen_profiles check skipped:', e.message);\n}\n\nconst newItems = items.filter(i => !existingUsernames.has(i.json.username));\n\n// \u2500\u2500 Log skipped profiles to skipped_profiles table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nconst skippedItems = items.filter(i => existingUsernames.has(i.json.username));\nif (skippedItems.length > 0) {\n  const skippedRows = skippedItems.map(i => ({\n    username: i.json.username,\n    skip_reason: 'ALREADY_KNOWN',\n    workflow_stage: 'Phase1-PreFilter',\n    source: i.json.source || 'unknown'\n  }));\n\n  try {\n    await supabaseRequest('POST', '/rest/v1/skipped_profiles', skippedRows);\n  } catch (e) {\n    console.log('Failed to log skipped profiles:', e.message);\n  }\n}\n\n// \u2500\u2500 Limit batch size to control Apify + Claude costs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nconst MAX_PROFILES = 20;\nconst limitedItems = newItems.slice(0, MAX_PROFILES);\n\nif (newItems.length > MAX_PROFILES) {\n  // Log the ones we're deferring\n  const deferredItems = newItems.slice(MAX_PROFILES);\n  const deferredRows = deferredItems.map(i => ({\n    username: i.json.username,\n    skip_reason: 'BATCH_LIMIT',\n    workflow_stage: 'Phase1-PreFilter',\n    source: i.json.source || 'unknown'\n  }));\n  try {\n    await supabaseRequest('POST', '/rest/v1/skipped_profiles', deferredRows);\n  } catch (e) {\n    console.log('Failed to log deferred profiles:', e.message);\n  }\n}\n\n// \u2500\u2500 Immediately mark these profiles as seen to prevent duplicate processing \u2500\u2500\n// This is critical: without this, concurrent runs will both pick up the same profiles\nif (limitedItems.length > 0) {\n  const seenRows = limitedItems.map(i => ({\n    username: i.json.username,\n    source: i.json.source || 'unknown',\n    source_type: i.json.sourceType || 'competitor_follower',\n    followers: i.json.followers || 0,\n    rejection_reason: 'IN_PROGRESS'\n  }));\n  try {\n    await supabaseRequest('POST', '/rest/v1/seen_profiles?on_conflict=username', seenRows);\n  } catch (e) {\n    console.log('Failed to mark profiles as seen:', e.message);\n  }\n}\n\nconsole.log(`Pre-filter: ${usernames.length} total, ${existingUsernames.size} known, ${newItems.length} new, ${limitedItems.length} sending (max ${MAX_PROFILES})`);\n\nreturn limitedItems;\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -5104,
          304
        ],
        "id": "8b097789-dcab-4fae-9760-27ebbd772274",
        "name": "Pre-Filter Known Profiles"
      },
      {
        "parameters": {
          "jsCode": "// Save to Seen Profiles \u2014 Phase 1 Code Node\n// Saves rejected profiles (failed filter) to seen_profiles table\n// so they don't get re-scraped on future runs.\n// Also logs to skipped_profiles table for audit trail.\n//\n// n8n WIRING:\n// IF node [FALSE branch, _skip=true] \u2192 this node \u2192 Done\n\nconst https = require('https');\nconst items = $input.all();\nconst SUPABASE_KEY = 'SUPABASE_SERVICE_ROLE_KEY_PLACEHOLDER';\n\nfunction supabaseRequest(method, path, body, extraHeaders) {\n  return new Promise((resolve, reject) => {\n    const data = body ? JSON.stringify(body) : '';\n    const hdrs = {\n      'apikey': SUPABASE_KEY,\n      'Authorization': `Bearer ${SUPABASE_KEY}`,\n      'Content-Type': 'application/json',\n      'Prefer': 'return=minimal',\n      'Content-Length': Buffer.byteLength(data),\n      ...extraHeaders\n    };\n    const options = {\n      hostname: 'gwytongsbnciyulphcjv.supabase.co',\n      path: path,\n      method: method,\n      headers: hdrs\n    };\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => responseData += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data: responseData }));\n    });\n    req.on('error', reject);\n    if (data) req.write(data);\n    req.end();\n  });\n}\n\nlet saved = 0;\n\nfor (const item of items) {\n  const data = item.json;\n  if (!data.username) continue;\n\n  try {\n    await supabaseRequest('POST', '/rest/v1/seen_profiles', {\n      username: data.username,\n      source: data.source || null,\n      source_type: data.source_type || 'tagged',\n      followers: data.followers || null,\n      rejection_reason: data.reason || 'unknown'\n    }, { 'Prefer': 'return=minimal,resolution=merge-duplicates' });\n    saved++;\n  } catch (e) {\n    console.log(`Failed to save ${data.username}:`, e.message);\n  }\n\n  // Also log to skipped_profiles for audit\n  try {\n    await supabaseRequest('POST', '/rest/v1/skipped_profiles', {\n      username: data.username,\n      skip_reason: data.reason || 'BELOW_THRESHOLD',\n      workflow_stage: 'Phase1-FilterReels',\n      source: data.source || 'unknown'\n    });\n  } catch (e) {\n    console.log(`Failed to log skip for ${data.username}:`, e.message);\n  }\n}\n\nconsole.log(`Saved ${saved}/${items.length} rejected profiles to seen_profiles`);\n\nreturn items;\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -3904,
          464
        ],
        "id": "c8263d2d-6fd1-48af-bd98-a467115bdd23",
        "name": "Save to Seen Profiles"
      }
    ],
    "connections": {
      "Sheets": {
        "main": [
          [
            {
              "node": "Sheets",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Start": {
        "main": [
          [
            {
              "node": "Settings1",
              "type": "main",
              "index": 0
            },
            {
              "node": "Get COLLABORATE Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Webhook Trigger": {
        "main": [
          [
            {
              "node": "Settings1",
              "type": "main",
              "index": 0
            },
            {
              "node": "Get COLLABORATE Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Collect Batch": {
        "main": [
          [
            {
              "node": "Aggregate All",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Aggregate All": {
        "main": [
          [
            {
              "node": "Dedupe Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Dedupe Profiles": {
        "main": [
          [
            {
              "node": "Pre-Filter Known Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Reels": {
        "main": [
          [
            {
              "node": "If",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Claude Analysis": {
        "main": [
          [
            {
              "node": "Merge",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge": {
        "main": [
          [
            {
              "node": "Save DB",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Save DB": {
        "main": [
          [
            {
              "node": "Download & Store Reels",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Apify: Tagged Posts": {
        "main": [
          [
            {
              "node": "Extract Profiles1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Settings1": {
        "main": [
          [
            {
              "node": "Apify: Tagged Posts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Profiles1": {
        "main": [
          [
            {
              "node": "Collect Batch",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Run an Actor and get dataset": {
        "main": [
          [
            {
              "node": "Filter Reels",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get COLLABORATE Profiles": {
        "main": [
          [
            {
              "node": "Loop Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Loop Profiles": {
        "main": [
          [
            {
              "node": "Phase 2 Done",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Build Storage URLs",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Gemini Video Analysis": {
        "main": [
          [
            {
              "node": "Parse Gemini Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Log to AI Logs": {
        "main": [
          [
            {
              "node": "Update Profile Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Profile Status": {
        "main": [
          [
            {
              "node": "Loop Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Code in JavaScript": {
        "main": [
          [
            {
              "node": "Skip Check",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Schedule Trigger": {
        "main": [
          []
        ]
      },
      "Parse Gemini Response": {
        "main": [
          [
            {
              "node": "Log to AI Logs",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait": {
        "main": [
          [
            {
              "node": "Code in JavaScript",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Download Reel 1": {
        "main": [
          [
            {
              "node": "Upload Reel 1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Upload Reel 1": {
        "main": [
          [
            {
              "node": "Download Reel 2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Download Reel 3": {
        "main": [
          [
            {
              "node": "Upload Reel 3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Upload Reel 3": {
        "main": [
          [
            {
              "node": "Wait",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Download Reel 2": {
        "main": [
          [
            {
              "node": "Upload Reel 2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Upload Reel 2": {
        "main": [
          [
            {
              "node": "Download Reel 3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter New Profiles": {
        "main": [
          []
        ]
      },
      "If": {
        "main": [
          [
            {
              "node": "Claude Analysis",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Save to Seen Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait1": {
        "main": [
          [
            {
              "node": "Run an Actor and get dataset",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Download & Store Reels": {
        "main": [
          [
            {
              "node": "Done",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Phase 2 Done": {
        "main": [
          []
        ]
      },
      "Build Storage URLs": {
        "main": [
          [
            {
              "node": "Download Reel 1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Skip Check": {
        "main": [
          [
            {
              "node": "Handle Skipped Profile",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Gemini Video Analysis",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Handle Skipped Profile": {
        "main": [
          [
            {
              "node": "Loop Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Pre-Filter Known Profiles": {
        "main": [
          [
            {
              "node": "Wait1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "import",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": []
  }
}